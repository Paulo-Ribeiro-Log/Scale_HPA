
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">k8s-hpa-manager/cmd/root.go (0.0%)</option>
				
				<option value="file1">k8s-hpa-manager/internal/config/kubeconfig.go (0.0%)</option>
				
				<option value="file2">k8s-hpa-manager/internal/kubernetes/client.go (0.0%)</option>
				
				<option value="file3">k8s-hpa-manager/internal/models/types.go (0.0%)</option>
				
				<option value="file4">k8s-hpa-manager/internal/session/manager.go (0.0%)</option>
				
				<option value="file5">k8s-hpa-manager/internal/tui/app.go (0.0%)</option>
				
				<option value="file6">k8s-hpa-manager/internal/tui/components.go (0.0%)</option>
				
				<option value="file7">k8s-hpa-manager/internal/tui/handlers.go (0.0%)</option>
				
				<option value="file8">k8s-hpa-manager/internal/tui/message.go (0.0%)</option>
				
				<option value="file9">k8s-hpa-manager/internal/tui/modern_integration.go (0.0%)</option>
				
				<option value="file10">k8s-hpa-manager/internal/tui/views.go (0.0%)</option>
				
				<option value="file11">k8s-hpa-manager/main.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package cmd

import (
        "fmt"
        "os"

        "k8s-hpa-manager/internal/tui"

        tea "github.com/charmbracelet/bubbletea"
        "github.com/spf13/cobra"
)

var (
        kubeconfig string
        debug      bool
)

var rootCmd = &amp;cobra.Command{
        Use:   "k8s-hpa-manager",
        Short: "Interactive Kubernetes HPA Manager",
        Long: `A terminal-based interface for managing Kubernetes Horizontal Pod Autoscalers (HPAs).
        
Features:
- Discover and connect to akspriv-* clusters
- Navigate and select multiple namespaces
- View and modify HPA configurations
- Trigger deployments rollouts
- Save and restore configuration sessions`,
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                // Initialize the TUI application
                app := tui.NewApp(kubeconfig, debug)

                // Create the Bubble Tea program
                p := tea.NewProgram(app, tea.WithAltScreen())

                // Run the program
                if _, err := p.Run(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to run application: %w", err)
                }</span>

                <span class="cov0" title="0">return nil</span>
        },
}

func Execute() error <span class="cov0" title="0">{
        return rootCmd.Execute()
}</span>

func init() <span class="cov0" title="0">{
        // Define flags
        rootCmd.PersistentFlags().StringVar(&amp;kubeconfig, "kubeconfig", "",
                "Path to kubeconfig file (default: $HOME/.kube/config)")
        rootCmd.PersistentFlags().BoolVar(&amp;debug, "debug", false,
                "Enable debug logging")

        // Set default kubeconfig path
        if home, exists := os.LookupEnv("HOME"); exists &amp;&amp; kubeconfig == "" </span><span class="cov0" title="0">{
                kubeconfig = fmt.Sprintf("%s/.kube/config", home)
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package config

import (
        "context"
        "fmt"
        "strings"
        "time"

        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/client-go/kubernetes"
        "k8s.io/client-go/tools/clientcmd"
        "k8s.io/client-go/tools/clientcmd/api"

        "k8s-hpa-manager/internal/models"
)

// KubeConfigManager gerencia a configuração do Kubernetes
type KubeConfigManager struct {
        configPath string
        config     *api.Config
        clients    map[string]kubernetes.Interface
}

// NewKubeConfigManager cria um novo gerenciador de kubeconfig
func NewKubeConfigManager(configPath string) (*KubeConfigManager, error) <span class="cov0" title="0">{
        config, err := clientcmd.LoadFromFile(configPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to load kubeconfig: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;KubeConfigManager{
                configPath: configPath,
                config:     config,
                clients:    make(map[string]kubernetes.Interface),
        }, nil</span>
}

// DiscoverClusters descobre todos os clusters que começam com "akspriv-"
func (k *KubeConfigManager) DiscoverClusters() []models.Cluster <span class="cov0" title="0">{
        var clusters []models.Cluster

        for contextName, _ := range k.config.Contexts </span><span class="cov0" title="0">{
                // Filtrar apenas clusters que começam com "akspriv-"
                if strings.HasPrefix(contextName, "akspriv-") </span><span class="cov0" title="0">{
                        cluster := models.Cluster{
                                Name:    contextName,
                                Context: contextName,
                                Status:  models.StatusUnknown,
                        }
                        clusters = append(clusters, cluster)
                }</span>
        }

        <span class="cov0" title="0">return clusters</span>
}

// TestClusterConnection testa a conectividade com um cluster
func (k *KubeConfigManager) TestClusterConnection(ctx context.Context, clusterName string) models.ConnectionStatus <span class="cov0" title="0">{
        client, err := k.getClient(clusterName)
        if err != nil </span><span class="cov0" title="0">{
                return models.StatusError
        }</span>

        // Criar contexto com timeout
        <span class="cov0" title="0">testCtx, cancel := context.WithTimeout(ctx, 10*time.Second)
        defer cancel()

        // Tentar listar namespaces como teste de conectividade
        _, err = client.CoreV1().Namespaces().List(testCtx, metav1.ListOptions{Limit: 1})
        if err != nil </span><span class="cov0" title="0">{
                if testCtx.Err() == context.DeadlineExceeded </span><span class="cov0" title="0">{
                        return models.StatusTimeout
                }</span>
                <span class="cov0" title="0">return models.StatusError</span>
        }

        <span class="cov0" title="0">return models.StatusConnected</span>
}

// GetClient retorna um cliente Kubernetes para o cluster especificado
func (k *KubeConfigManager) GetClient(clusterName string) (kubernetes.Interface, error) <span class="cov0" title="0">{
        return k.getClient(clusterName)
}</span>

// getClient cria ou retorna um cliente existente para o cluster
func (k *KubeConfigManager) getClient(clusterName string) (kubernetes.Interface, error) <span class="cov0" title="0">{
        // Verificar se já temos um cliente para este cluster
        if client, exists := k.clients[clusterName]; exists </span><span class="cov0" title="0">{
                return client, nil
        }</span>

        // Criar configuração do cliente para o contexto específico
        <span class="cov0" title="0">clientConfig := clientcmd.NewNonInteractiveDeferredLoadingClientConfig(
                &amp;clientcmd.ClientConfigLoadingRules{ExplicitPath: k.configPath},
                &amp;clientcmd.ConfigOverrides{CurrentContext: clusterName},
        )

        // Obter configuração REST
        restConfig, err := clientConfig.ClientConfig()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create client config for %s: %w", clusterName, err)
        }</span>

        // Configurar timeouts
        <span class="cov0" title="0">restConfig.Timeout = 30 * time.Second
        restConfig.QPS = 50
        restConfig.Burst = 100

        // Criar cliente Kubernetes
        client, err := kubernetes.NewForConfig(restConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create kubernetes client for %s: %w", clusterName, err)
        }</span>

        // Armazenar cliente para reuso
        <span class="cov0" title="0">k.clients[clusterName] = client

        return client, nil</span>
}

// ListContexts retorna todos os contextos disponíveis
func (k *KubeConfigManager) ListContexts() []string <span class="cov0" title="0">{
        var contexts []string
        for contextName := range k.config.Contexts </span><span class="cov0" title="0">{
                contexts = append(contexts, contextName)
        }</span>
        <span class="cov0" title="0">return contexts</span>
}

// GetCurrentContext retorna o contexto atual
func (k *KubeConfigManager) GetCurrentContext() string <span class="cov0" title="0">{
        return k.config.CurrentContext
}</span>

// ValidateConfig valida a configuração do kubeconfig
func (k *KubeConfigManager) ValidateConfig() error <span class="cov0" title="0">{
        if k.config == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("kubeconfig is not loaded")
        }</span>

        <span class="cov0" title="0">if len(k.config.Contexts) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no contexts found in kubeconfig")
        }</span>

        // Verificar se existem clusters akspriv-*
        <span class="cov0" title="0">hasAksprivClusters := false
        for contextName := range k.config.Contexts </span><span class="cov0" title="0">{
                if strings.HasPrefix(contextName, "akspriv-") </span><span class="cov0" title="0">{
                        hasAksprivClusters = true
                        break</span>
                }
        }

        <span class="cov0" title="0">if !hasAksprivClusters </span><span class="cov0" title="0">{
                return fmt.Errorf("no akspriv-* clusters found in kubeconfig")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetClusterInfo retorna informações detalhadas sobre um cluster
func (k *KubeConfigManager) GetClusterInfo(clusterName string) (*ClusterInfo, error) <span class="cov0" title="0">{
        context, exists := k.config.Contexts[clusterName]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("context %s not found", clusterName)
        }</span>

        <span class="cov0" title="0">cluster, exists := k.config.Clusters[context.Cluster]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cluster %s not found", context.Cluster)
        }</span>

        <span class="cov0" title="0">return &amp;ClusterInfo{
                Name:      clusterName,
                Server:    cluster.Server,
                Context:   clusterName,
                Namespace: context.Namespace,
        }, nil</span>
}

// ClusterInfo representa informações sobre um cluster
type ClusterInfo struct {
        Name      string
        Server    string
        Context   string
        Namespace string
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package kubernetes

import (
        "context"
        "fmt"
        "time"

        autoscalingv2 "k8s.io/api/autoscaling/v2"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/client-go/kubernetes"

        "k8s-hpa-manager/internal/models"
)

// systemNamespaces lista os namespaces de sistema que devem ser filtrados
var systemNamespaces = map[string]bool{
        "default":                       true,
        "kube-system":                   true,
        "kube-public":                   true,
        "kube-node-lease":               true,
        "gatekeeper-system":             true,
        "istio-system":                  true,
        "istio-injection":               true,
        "cert-manager":                  true,
        "monitoring":                    true,
        "prometheus":                    true,
        "grafana":                       true,
        "elastic-system":                true,
        "logging":                       true,
        "dynatrace":                     true,
        "flux-system":                   true,
        "argocd":                        true,
        "guardicore":                    true,
        "guardicore-orch":               true,
        "cattle-system":                 true,
        "longhorn-system":               true,
        "metallb-system":                true,
        "calico-system":                 true,
        "tigera-operator":               true,
        "azure-arc":                     true,
        "cluster-baseline-pod-security": true,
        "dsv":                           true,
        "velero":                        true,
        "calico-apiserver":              true,
        "rbac-manager":                  true,
        "spinnaker":                     true,
        "aks-command":                   true,
        "dsv-system":                    true,
}

// isSystemNamespace verifica se um namespace é de sistema e deve ser filtrado
func isSystemNamespace(namespace string) bool <span class="cov0" title="0">{
        return systemNamespaces[namespace]
}</span>

// Client encapsula as operações do Kubernetes
type Client struct {
        clientset kubernetes.Interface
        cluster   string
}

// NewClient cria um novo cliente Kubernetes
func NewClient(clientset kubernetes.Interface, clusterName string) *Client <span class="cov0" title="0">{
        return &amp;Client{
                clientset: clientset,
                cluster:   clusterName,
        }
}</span>

// ListNamespaces lista todos os namespaces do cluster
func (c *Client) ListNamespaces(ctx context.Context, showSystemNamespaces bool) ([]models.Namespace, error) <span class="cov0" title="0">{
        namespaces, err := c.clientset.CoreV1().Namespaces().List(ctx, metav1.ListOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list namespaces in cluster %s: %w", c.cluster, err)
        }</span>

        <span class="cov0" title="0">var result []models.Namespace
        for _, ns := range namespaces.Items </span><span class="cov0" title="0">{
                // Filtrar namespaces de sistema se showSystemNamespaces for false
                if !showSystemNamespaces &amp;&amp; isSystemNamespace(ns.Name) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">namespace := models.Namespace{
                        Name:     ns.Name,
                        Cluster:  c.cluster,
                        HPACount: 0, // Será contado assincronamente depois
                }
                result = append(result, namespace)</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}

// ListHPAs lista todos os HPAs em um namespace
func (c *Client) ListHPAs(ctx context.Context, namespace string) ([]models.HPA, error) <span class="cov0" title="0">{
        hpas, err := c.clientset.AutoscalingV2().HorizontalPodAutoscalers(namespace).List(ctx, metav1.ListOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list HPAs in namespace %s/%s: %w", c.cluster, namespace, err)
        }</span>

        <span class="cov0" title="0">var result []models.HPA
        for _, hpa := range hpas.Items </span><span class="cov0" title="0">{
                modelHPA := c.convertHPAToModel(&amp;hpa)
                result = append(result, modelHPA)
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// UpdateHPA atualiza um HPA
func (c *Client) UpdateHPA(ctx context.Context, hpa *models.HPA) error <span class="cov0" title="0">{
        // Obter o HPA atual
        currentHPA, err := c.clientset.AutoscalingV2().HorizontalPodAutoscalers(hpa.Namespace).Get(ctx, hpa.Name, metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get HPA %s/%s/%s: %w", c.cluster, hpa.Namespace, hpa.Name, err)
        }</span>

        // Atualizar valores
        <span class="cov0" title="0">currentHPA.Spec.MinReplicas = hpa.MinReplicas
        currentHPA.Spec.MaxReplicas = hpa.MaxReplicas

        // Atualizar métricas se especificadas
        if hpa.TargetCPU != nil || hpa.TargetMemory != nil </span><span class="cov0" title="0">{
                c.updateHPAMetrics(currentHPA, hpa)
        }</span>

        // Aplicar atualização
        <span class="cov0" title="0">_, err = c.clientset.AutoscalingV2().HorizontalPodAutoscalers(hpa.Namespace).Update(ctx, currentHPA, metav1.UpdateOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update HPA %s/%s/%s: %w", c.cluster, hpa.Namespace, hpa.Name, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// RolloutDeployment executa rollout restart em um deployment
func (c *Client) RolloutDeployment(ctx context.Context, namespace, deploymentName string) error <span class="cov0" title="0">{
        // Obter deployment
        deployment, err := c.clientset.AppsV1().Deployments(namespace).Get(ctx, deploymentName, metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get deployment %s/%s/%s: %w", c.cluster, namespace, deploymentName, err)
        }</span>

        // Adicionar annotation para forçar rollout
        <span class="cov0" title="0">if deployment.Spec.Template.Annotations == nil </span><span class="cov0" title="0">{
                deployment.Spec.Template.Annotations = make(map[string]string)
        }</span>
        <span class="cov0" title="0">deployment.Spec.Template.Annotations["kubectl.kubernetes.io/restartedAt"] = time.Now().Format(time.RFC3339)

        // Atualizar deployment
        _, err = c.clientset.AppsV1().Deployments(namespace).Update(ctx, deployment, metav1.UpdateOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to rollout deployment %s/%s/%s: %w", c.cluster, namespace, deploymentName, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetDeploymentFromHPA obtém o nome do deployment associado ao HPA
func (c *Client) GetDeploymentFromHPA(ctx context.Context, namespace, hpaName string) (string, error) <span class="cov0" title="0">{
        hpa, err := c.clientset.AutoscalingV2().HorizontalPodAutoscalers(namespace).Get(ctx, hpaName, metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get HPA %s/%s/%s: %w", c.cluster, namespace, hpaName, err)
        }</span>

        // Verificar se o target é um Deployment
        <span class="cov0" title="0">if hpa.Spec.ScaleTargetRef.Kind == "Deployment" </span><span class="cov0" title="0">{
                return hpa.Spec.ScaleTargetRef.Name, nil
        }</span>

        <span class="cov0" title="0">return "", fmt.Errorf("HPA %s does not target a Deployment (targets %s)", hpaName, hpa.Spec.ScaleTargetRef.Kind)</span>
}

// TestConnection testa a conectividade com o cluster
func (c *Client) TestConnection(ctx context.Context) error <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
        defer cancel()

        _, err := c.clientset.CoreV1().Namespaces().List(ctx, metav1.ListOptions{Limit: 1})
        return err
}</span>

// CountHPAs conta o número de HPAs em um namespace
func (c *Client) CountHPAs(ctx context.Context, namespace string) (int, error) <span class="cov0" title="0">{
        hpas, err := c.clientset.AutoscalingV2().HorizontalPodAutoscalers(namespace).List(ctx, metav1.ListOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return len(hpas.Items), nil</span>
}

// convertHPAToModel converte um HPA do Kubernetes para o modelo interno
func (c *Client) convertHPAToModel(hpa *autoscalingv2.HorizontalPodAutoscaler) models.HPA <span class="cov0" title="0">{
        modelHPA := models.HPA{
                Name:            hpa.Name,
                Namespace:       hpa.Namespace,
                Cluster:         c.cluster,
                MinReplicas:     hpa.Spec.MinReplicas,
                MaxReplicas:     hpa.Spec.MaxReplicas,
                CurrentReplicas: hpa.Status.CurrentReplicas,
                LastUpdated:     time.Now(), // HPA doesn't have LastUpdateTime field
        }

        // Extrair métricas de CPU e Memory
        for _, metric := range hpa.Spec.Metrics </span><span class="cov0" title="0">{
                if metric.Type == autoscalingv2.ResourceMetricSourceType &amp;&amp; metric.Resource != nil </span><span class="cov0" title="0">{
                        switch metric.Resource.Name </span>{
                        case corev1.ResourceCPU:<span class="cov0" title="0">
                                if metric.Resource.Target.AverageUtilization != nil </span><span class="cov0" title="0">{
                                        modelHPA.TargetCPU = metric.Resource.Target.AverageUtilization
                                }</span>
                        case corev1.ResourceMemory:<span class="cov0" title="0">
                                if metric.Resource.Target.AverageUtilization != nil </span><span class="cov0" title="0">{
                                        modelHPA.TargetMemory = metric.Resource.Target.AverageUtilization
                                }</span>
                        }
                }
        }

        // Salvar valores originais
        <span class="cov0" title="0">modelHPA.OriginalValues = &amp;models.HPAValues{
                MinReplicas:  modelHPA.MinReplicas,
                MaxReplicas:  modelHPA.MaxReplicas,
                TargetCPU:    modelHPA.TargetCPU,
                TargetMemory: modelHPA.TargetMemory,
        }

        return modelHPA</span>
}

// updateHPAMetrics atualiza as métricas de um HPA
func (c *Client) updateHPAMetrics(hpa *autoscalingv2.HorizontalPodAutoscaler, model *models.HPA) <span class="cov0" title="0">{
        // Atualizar ou criar métricas
        for i, metric := range hpa.Spec.Metrics </span><span class="cov0" title="0">{
                if metric.Type == autoscalingv2.ResourceMetricSourceType &amp;&amp; metric.Resource != nil </span><span class="cov0" title="0">{
                        switch metric.Resource.Name </span>{
                        case corev1.ResourceCPU:<span class="cov0" title="0">
                                if model.TargetCPU != nil </span><span class="cov0" title="0">{
                                        hpa.Spec.Metrics[i].Resource.Target.AverageUtilization = model.TargetCPU
                                }</span>
                        case corev1.ResourceMemory:<span class="cov0" title="0">
                                if model.TargetMemory != nil </span><span class="cov0" title="0">{
                                        hpa.Spec.Metrics[i].Resource.Target.AverageUtilization = model.TargetMemory
                                }</span>
                        }
                }
        }

        // Se não existem métricas, criar novas
        <span class="cov0" title="0">if len(hpa.Spec.Metrics) == 0 </span><span class="cov0" title="0">{
                if model.TargetCPU != nil </span><span class="cov0" title="0">{
                        cpuMetric := autoscalingv2.MetricSpec{
                                Type: autoscalingv2.ResourceMetricSourceType,
                                Resource: &amp;autoscalingv2.ResourceMetricSource{
                                        Name: corev1.ResourceCPU,
                                        Target: autoscalingv2.MetricTarget{
                                                Type:               autoscalingv2.UtilizationMetricType,
                                                AverageUtilization: model.TargetCPU,
                                        },
                                },
                        }
                        hpa.Spec.Metrics = append(hpa.Spec.Metrics, cpuMetric)
                }</span>

                <span class="cov0" title="0">if model.TargetMemory != nil </span><span class="cov0" title="0">{
                        memoryMetric := autoscalingv2.MetricSpec{
                                Type: autoscalingv2.ResourceMetricSourceType,
                                Resource: &amp;autoscalingv2.ResourceMetricSource{
                                        Name: corev1.ResourceMemory,
                                        Target: autoscalingv2.MetricTarget{
                                                Type:               autoscalingv2.UtilizationMetricType,
                                                AverageUtilization: model.TargetMemory,
                                        },
                                },
                        }
                        hpa.Spec.Metrics = append(hpa.Spec.Metrics, memoryMetric)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package models

import (
        "time"
)

// AppState representa o estado principal da aplicação
type AppState int

const (
        StateClusterDiscovery AppState = iota
        StateNamespaceSelection
        StateHPAManagement
        StateHPAEditing
        StateSessionManager
        StateOperationProgress
)

// Campos editáveis de HPA
const (
        FieldMinReplicas = "min_replicas"
        FieldMaxReplicas = "max_replicas"
        FieldTargetCPU   = "target_cpu"
        FieldTargetMemory = "target_memory"
        FieldRollout     = "rollout"
)

// Cluster representa um cluster Kubernetes
type Cluster struct {
        Name      string          `json:"name"`
        Context   string          `json:"context"`
        Status    ConnectionStatus `json:"status"`
        Error     string          `json:"error,omitempty"`
        Selected  bool            `json:"selected"`
}

// ConnectionStatus indica o status de conectividade do cluster
type ConnectionStatus int

const (
        StatusUnknown ConnectionStatus = iota
        StatusConnected
        StatusTimeout
        StatusError
)

func (s ConnectionStatus) String() string <span class="cov0" title="0">{
        switch s </span>{
        case StatusConnected:<span class="cov0" title="0">
                return "connected ✓"</span>
        case StatusTimeout:<span class="cov0" title="0">
                return "timeout ⚠️"</span>
        case StatusError:<span class="cov0" title="0">
                return "error ❌"</span>
        default:<span class="cov0" title="0">
                return "checking..."</span>
        }
}

// Namespace representa um namespace Kubernetes
type Namespace struct {
        Name        string `json:"name"`
        Cluster     string `json:"cluster"`
        HPACount    int    `json:"hpa_count"`
        Selected    bool   `json:"selected"`
}

// HPA representa um Horizontal Pod Autoscaler
type HPA struct {
        Name              string    `json:"name"`
        Namespace         string    `json:"namespace"`
        Cluster           string    `json:"cluster"`
        MinReplicas       *int32    `json:"min_replicas"`
        MaxReplicas       int32     `json:"max_replicas"`
        CurrentReplicas   int32     `json:"current_replicas"`
        TargetCPU         *int32    `json:"target_cpu,omitempty"`
        TargetMemory      *int32    `json:"target_memory,omitempty"`
        Selected          bool      `json:"selected"`
        Modified          bool      `json:"modified"`
        OriginalValues    *HPAValues `json:"original_values"`
        LastUpdated       time.Time `json:"last_updated"`
}

// HPAValues armazena os valores de configuração de um HPA
type HPAValues struct {
        MinReplicas  *int32 `json:"min_replicas"`
        MaxReplicas  int32  `json:"max_replicas"`
        TargetCPU    *int32 `json:"target_cpu,omitempty"`
        TargetMemory *int32 `json:"target_memory,omitempty"`
}

// HPAChange representa uma mudança em um HPA
type HPAChange struct {
        Cluster        string     `json:"cluster"`
        Namespace      string     `json:"namespace"`
        HPAName        string     `json:"hpa_name"`
        OriginalValues *HPAValues `json:"original_values"`
        NewValues      *HPAValues `json:"new_values"`
        Applied        bool       `json:"applied"`
        AppliedAt      *time.Time `json:"applied_at,omitempty"`
        RolloutTriggered bool     `json:"rollout_triggered"`
}

// Session representa uma sessão salva de modificações
type Session struct {
        Name           string            `json:"name"`
        CreatedAt      time.Time         `json:"created_at"`
        CreatedBy      string            `json:"created_by"`
        Description    string            `json:"description,omitempty"`
        TemplateUsed   string            `json:"template_used"`
        Metadata       *SessionMetadata  `json:"metadata"`
        Changes        []HPAChange       `json:"changes"`
        RollbackData   *RollbackData     `json:"rollback_data"`
}

// SessionMetadata contém metadados da sessão
type SessionMetadata struct {
        ClustersAffected []string `json:"clusters_affected"`
        NamespacesCount  int      `json:"namespaces_count"`
        HPACount         int      `json:"hpa_count"`
        TotalChanges     int      `json:"total_changes"`
}

// RollbackData contém informações para rollback
type RollbackData struct {
        OriginalStateCaptured   bool `json:"original_state_captured"`
        CanRollback            bool `json:"can_rollback"`
        RollbackScriptGenerated bool `json:"rollback_script_generated"`
}

// SessionTemplate representa um template para nomenclatura de sessões
type SessionTemplate struct {
        Name        string            `json:"name"`
        Pattern     string            `json:"pattern"`
        Description string            `json:"description"`
        Variables   map[string]string `json:"variables"`
}

// OperationStatus representa o status de uma operação
type OperationStatus int

const (
        OpPending OperationStatus = iota
        OpInProgress
        OpCompleted
        OpFailed
        OpCancelled
)

func (s OperationStatus) String() string <span class="cov0" title="0">{
        switch s </span>{
        case OpPending:<span class="cov0" title="0">
                return "⏳ Pending"</span>
        case OpInProgress:<span class="cov0" title="0">
                return "🔄 In Progress"</span>
        case OpCompleted:<span class="cov0" title="0">
                return "✅ Completed"</span>
        case OpFailed:<span class="cov0" title="0">
                return "❌ Failed"</span>
        case OpCancelled:<span class="cov0" title="0">
                return "🚫 Cancelled"</span>
        default:<span class="cov0" title="0">
                return "❓ Unknown"</span>
        }
}

// Operation representa uma operação sendo executada
type Operation struct {
        ID          string          `json:"id"`
        Type        string          `json:"type"` // "update_hpa", "rollout", etc.
        Target      string          `json:"target"` // cluster/namespace/hpa
        Status      OperationStatus `json:"status"`
        Progress    float64         `json:"progress"` // 0.0 - 1.0
        Message     string          `json:"message"`
        Error       string          `json:"error,omitempty"`
        StartedAt   time.Time       `json:"started_at"`
        CompletedAt *time.Time      `json:"completed_at,omitempty"`
}

// AppModel representa o modelo principal da aplicação
type AppModel struct {
        State       AppState
        Clusters    []Cluster
        Namespaces  []Namespace
        HPAs        []HPA
        Sessions    []Session
        CurrentSession *Session
        Operations  []Operation
        
        // UI State
        Loading        bool
        Error          string
        SelectedIndex  int
        
        // Navigation
        ActiveTab      int
        ShowHelp       bool
        PreviousState  AppState // Estado anterior para voltar corretamente
        
        // Editing
        EditingHPA     *HPA
        FormFields     map[string]string
        ActiveField    string // Campo atualmente em foco para edição
        PerformRollout bool   // Se deve executar rollout após aplicar mudanças
        
        // Session Management
        SessionName    string
        SessionTemplate string
        AutoTimestamp  bool
        EnteringSessionName bool // Se está digitando nome da sessão
        LoadingSessionData  bool // Se está carregando dados de uma sessão
        
        // Filters
        ShowSystemNamespaces bool
}</pre>
		
		<pre class="file" id="file4" style="display: none">package session

import (
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "sort"
        "strings"
        "time"

        "k8s-hpa-manager/internal/models"
)

// Manager gerencia as sessões de configuração
type Manager struct {
        sessionDir string
        templates  []models.SessionTemplate
}

// NewManager cria um novo gerenciador de sessões
func NewManager() (*Manager, error) <span class="cov0" title="0">{
        // Criar diretório de sessões no home do usuário
        homeDir, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user home directory: %w", err)
        }</span>

        <span class="cov0" title="0">sessionDir := filepath.Join(homeDir, ".k8s-hpa-manager", "sessions")
        if err := os.MkdirAll(sessionDir, 0755); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create session directory: %w", err)
        }</span>

        <span class="cov0" title="0">manager := &amp;Manager{
                sessionDir: sessionDir,
                templates:  getDefaultTemplates(),
        }

        return manager, nil</span>
}

// SaveSession salva uma sessão com nome personalizado
func (m *Manager) SaveSession(session *models.Session) error <span class="cov0" title="0">{
        if session.Name == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("session name cannot be empty")
        }</span>

        // Validar nome da sessão
        <span class="cov0" title="0">if err := m.validateSessionName(session.Name); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Garantir que metadados estão preenchidos
        <span class="cov0" title="0">if session.Metadata == nil </span><span class="cov0" title="0">{
                session.Metadata = m.generateMetadata(session.Changes)
        }</span>

        // Definir timestamps
        <span class="cov0" title="0">if session.CreatedAt.IsZero() </span><span class="cov0" title="0">{
                session.CreatedAt = time.Now()
        }</span>

        // Definir usuário se não especificado
        <span class="cov0" title="0">if session.CreatedBy == "" </span><span class="cov0" title="0">{
                if user := os.Getenv("USER"); user != "" </span><span class="cov0" title="0">{
                        session.CreatedBy = user
                }</span> else<span class="cov0" title="0"> {
                        session.CreatedBy = "unknown"
                }</span>
        }

        // Serializar para JSON
        <span class="cov0" title="0">data, err := json.MarshalIndent(session, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal session: %w", err)
        }</span>

        // Salvar no arquivo
        <span class="cov0" title="0">filename := fmt.Sprintf("%s.json", session.Name)
        filepath := filepath.Join(m.sessionDir, filename)

        if err := os.WriteFile(filepath, data, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save session file: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// LoadSession carrega uma sessão pelo nome
func (m *Manager) LoadSession(name string) (*models.Session, error) <span class="cov0" title="0">{
        filename := fmt.Sprintf("%s.json", name)
        filepath := filepath.Join(m.sessionDir, filename)

        data, err := os.ReadFile(filepath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read session file: %w", err)
        }</span>

        <span class="cov0" title="0">var session models.Session
        if err := json.Unmarshal(data, &amp;session); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal session: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;session, nil</span>
}

// ListSessions lista todas as sessões salvas
func (m *Manager) ListSessions() ([]models.Session, error) <span class="cov0" title="0">{
        files, err := os.ReadDir(m.sessionDir)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read session directory: %w", err)
        }</span>

        <span class="cov0" title="0">var sessions []models.Session

        for _, file := range files </span><span class="cov0" title="0">{
                if !strings.HasSuffix(file.Name(), ".json") </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">sessionName := strings.TrimSuffix(file.Name(), ".json")
                session, err := m.LoadSession(sessionName)
                if err != nil </span><span class="cov0" title="0">{
                        // Log error mas continue listando outras sessões
                        continue</span>
                }

                <span class="cov0" title="0">sessions = append(sessions, *session)</span>
        }

        // Ordenar por data de criação (mais recente primeiro)
        <span class="cov0" title="0">sort.Slice(sessions, func(i, j int) bool </span><span class="cov0" title="0">{
                return sessions[i].CreatedAt.After(sessions[j].CreatedAt)
        }</span>)

        <span class="cov0" title="0">return sessions, nil</span>
}

// DeleteSession remove uma sessão
func (m *Manager) DeleteSession(name string) error <span class="cov0" title="0">{
        filename := fmt.Sprintf("%s.json", name)
        filepath := filepath.Join(m.sessionDir, filename)

        if err := os.Remove(filepath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete session file: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// RenameSession renomeia uma sessão
func (m *Manager) RenameSession(oldName, newName string) error <span class="cov0" title="0">{
        if err := m.validateSessionName(newName); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">oldPath := filepath.Join(m.sessionDir, fmt.Sprintf("%s.json", oldName))
        newPath := filepath.Join(m.sessionDir, fmt.Sprintf("%s.json", newName))
        _ = newPath // TODO: implement rename functionality

        // Carregar sessão
        session, err := m.LoadSession(oldName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Atualizar nome
        <span class="cov0" title="0">session.Name = newName

        // Salvar com novo nome
        if err := m.SaveSession(session); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Remover arquivo antigo
        <span class="cov0" title="0">return os.Remove(oldPath)</span>
}

// GenerateSessionName gera um nome de sessão baseado no template
func (m *Manager) GenerateSessionName(baseName, templatePattern string, changes []models.HPAChange) string <span class="cov0" title="0">{
        name := templatePattern

        // Substituir variáveis
        name = strings.ReplaceAll(name, "{action}", baseName)
        name = strings.ReplaceAll(name, "{timestamp}", time.Now().Format("02-01-06_15:04:05"))
        name = strings.ReplaceAll(name, "{date}", time.Now().Format("02-01-06"))
        name = strings.ReplaceAll(name, "{time}", time.Now().Format("15:04:05"))

        if user := os.Getenv("USER"); user != "" </span><span class="cov0" title="0">{
                name = strings.ReplaceAll(name, "{user}", user)
        }</span> else<span class="cov0" title="0"> {
                name = strings.ReplaceAll(name, "{user}", "unknown")
        }</span>

        // Extrair informações dos changes
        <span class="cov0" title="0">if len(changes) &gt; 0 </span><span class="cov0" title="0">{
                clustersMap := make(map[string]bool)
                for _, change := range changes </span><span class="cov0" title="0">{
                        clustersMap[change.Cluster] = true
                }</span>

                <span class="cov0" title="0">var clusters []string
                for cluster := range clustersMap </span><span class="cov0" title="0">{
                        clusters = append(clusters, cluster)
                }</span>

                <span class="cov0" title="0">if len(clusters) == 1 </span><span class="cov0" title="0">{
                        name = strings.ReplaceAll(name, "{cluster}", clusters[0])
                        // Extrair ambiente do nome do cluster
                        if env := extractEnvironment(clusters[0]); env != "" </span><span class="cov0" title="0">{
                                name = strings.ReplaceAll(name, "{env}", env)
                        }</span>
                } else<span class="cov0" title="0"> {
                        name = strings.ReplaceAll(name, "{cluster}", "multi-cluster")
                        name = strings.ReplaceAll(name, "{env}", "multi-env")
                }</span>

                <span class="cov0" title="0">name = strings.ReplaceAll(name, "{hpa_count}", fmt.Sprintf("%d", len(changes)))</span>
        }

        // Limpar variáveis não substituídas
        <span class="cov0" title="0">name = strings.ReplaceAll(name, "{cluster}", "unknown")
        name = strings.ReplaceAll(name, "{env}", "unknown")
        name = strings.ReplaceAll(name, "{hpa_count}", "0")

        return name</span>
}

// GetTemplates retorna os templates disponíveis
func (m *Manager) GetTemplates() []models.SessionTemplate <span class="cov0" title="0">{
        return m.templates
}</span>

// SessionExists verifica se uma sessão existe
func (m *Manager) SessionExists(name string) bool <span class="cov0" title="0">{
        filename := fmt.Sprintf("%s.json", name)
        filepath := filepath.Join(m.sessionDir, filename)

        _, err := os.Stat(filepath)
        return !os.IsNotExist(err)
}</span>

// CreateAutoSave cria uma sessão de auto-save
func (m *Manager) CreateAutoSave(changes []models.HPAChange) (*models.Session, error) <span class="cov0" title="0">{
        name := fmt.Sprintf("autosave_%s", time.Now().Format("02-01-06_15:04:05"))

        session := &amp;models.Session{
                Name:         name,
                CreatedAt:    time.Now(),
                Description:  "Auto-saved session",
                Changes:      changes,
                Metadata:     m.generateMetadata(changes),
                RollbackData: &amp;models.RollbackData{
                        OriginalStateCaptured:   true,
                        CanRollback:            true,
                        RollbackScriptGenerated: false,
                },
        }

        if err := m.SaveSession(session); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Limpar autosaves antigos (manter apenas 5)
        <span class="cov0" title="0">m.cleanupAutoSaves()

        return session, nil</span>
}

// validateSessionName valida o nome da sessão
func (m *Manager) validateSessionName(name string) error <span class="cov0" title="0">{
        if name == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("session name cannot be empty")
        }</span>

        <span class="cov0" title="0">if len(name) &gt; 50 </span><span class="cov0" title="0">{
                return fmt.Errorf("session name cannot exceed 50 characters")
        }</span>

        // Verificar caracteres permitidos
        <span class="cov0" title="0">for _, r := range name </span><span class="cov0" title="0">{
                if !((r &gt;= 'a' &amp;&amp; r &lt;= 'z') || (r &gt;= 'A' &amp;&amp; r &lt;= 'Z') || (r &gt;= '0' &amp;&amp; r &lt;= '9') || r == '_' || r == '-') </span><span class="cov0" title="0">{
                        return fmt.Errorf("session name can only contain letters, numbers, underscore and dash")
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// generateMetadata gera metadados para uma sessão
func (m *Manager) generateMetadata(changes []models.HPAChange) *models.SessionMetadata <span class="cov0" title="0">{
        clustersMap := make(map[string]bool)
        namespacesMap := make(map[string]bool)

        for _, change := range changes </span><span class="cov0" title="0">{
                clustersMap[change.Cluster] = true
                namespacesMap[fmt.Sprintf("%s/%s", change.Cluster, change.Namespace)] = true
        }</span>

        <span class="cov0" title="0">var clusters []string
        for cluster := range clustersMap </span><span class="cov0" title="0">{
                clusters = append(clusters, cluster)
        }</span>

        <span class="cov0" title="0">return &amp;models.SessionMetadata{
                ClustersAffected: clusters,
                NamespacesCount:  len(namespacesMap),
                HPACount:         len(changes),
                TotalChanges:     len(changes),
        }</span>
}

// cleanupAutoSaves remove autosaves antigos, mantendo apenas os 5 mais recentes
func (m *Manager) cleanupAutoSaves() <span class="cov0" title="0">{
        files, err := os.ReadDir(m.sessionDir)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">var autoSaves []os.DirEntry
        for _, file := range files </span><span class="cov0" title="0">{
                if strings.HasPrefix(file.Name(), "autosave_") &amp;&amp; strings.HasSuffix(file.Name(), ".json") </span><span class="cov0" title="0">{
                        autoSaves = append(autoSaves, file)
                }</span>
        }

        // Se temos mais de 5 autosaves, remover os mais antigos
        <span class="cov0" title="0">if len(autoSaves) &gt; 5 </span><span class="cov0" title="0">{
                // Ordenar por data de modificação
                sort.Slice(autoSaves, func(i, j int) bool </span><span class="cov0" title="0">{
                        info1, _ := autoSaves[i].Info()
                        info2, _ := autoSaves[j].Info()
                        return info1.ModTime().After(info2.ModTime())
                }</span>)

                // Remover os mais antigos
                <span class="cov0" title="0">for i := 5; i &lt; len(autoSaves); i++ </span><span class="cov0" title="0">{
                        os.Remove(filepath.Join(m.sessionDir, autoSaves[i].Name()))
                }</span>
        }
}

// extractEnvironment extrai o ambiente do nome do cluster
func extractEnvironment(clusterName string) string <span class="cov0" title="0">{
        lower := strings.ToLower(clusterName)
        if strings.Contains(lower, "prod") </span><span class="cov0" title="0">{
                return "production"
        }</span>
        <span class="cov0" title="0">if strings.Contains(lower, "dev") </span><span class="cov0" title="0">{
                return "development"
        }</span>
        <span class="cov0" title="0">if strings.Contains(lower, "staging") || strings.Contains(lower, "stage") </span><span class="cov0" title="0">{
                return "staging"
        }</span>
        <span class="cov0" title="0">if strings.Contains(lower, "test") </span><span class="cov0" title="0">{
                return "testing"
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// getDefaultTemplates retorna os templates padrão para nomes de sessão
func getDefaultTemplates() []models.SessionTemplate <span class="cov0" title="0">{
        return []models.SessionTemplate{
                {
                        Name:        "Action + Cluster + Timestamp",
                        Pattern:     "{action}_{cluster}_{timestamp}",
                        Description: "Ex: Up-sizing_aks-teste-prd_19-09-24_14:23:45",
                        Variables: map[string]string{
                                "action":    "Ação customizada",
                                "cluster":   "Nome do cluster principal",
                                "timestamp": "dd-mm-yy_hh:mm:ss",
                        },
                },
                {
                        Name:        "Action + Environment + Date",
                        Pattern:     "{action}_{env}_{date}",
                        Description: "Ex: Scale-down_production_19-09-24",
                        Variables: map[string]string{
                                "action": "Ação customizada",
                                "env":    "Ambiente (dev/prod/staging)",
                                "date":   "dd-mm-yy",
                        },
                },
                {
                        Name:        "Timestamp + Action + User",
                        Pattern:     "{timestamp}_{action}_{user}",
                        Description: "Ex: 19-09-24_14:23_Emergency-scale_admin",
                        Variables: map[string]string{
                                "timestamp": "dd-mm-yy_hh:mm:ss",
                                "action":    "Ação customizada",
                                "user":      "Usuário atual do sistema",
                        },
                },
                {
                        Name:        "Quick Save",
                        Pattern:     "Quick-save_{timestamp}",
                        Description: "Ex: Quick-save_19-09-24_14:25:12",
                        Variables: map[string]string{
                                "timestamp": "dd-mm-yy_hh:mm:ss",
                        },
                },
        }
}</pre>
		
		<pre class="file" id="file5" style="display: none">package tui

import (
        "context"
        "fmt"

        tea "github.com/charmbracelet/bubbletea"

        "k8s-hpa-manager/internal/config"
        "k8s-hpa-manager/internal/kubernetes"
        "k8s-hpa-manager/internal/models"
        "k8s-hpa-manager/internal/session"
)

// App representa a aplicação principal
type App struct {
        // Configuração
        kubeconfigPath string
        debug          bool

        // Managers
        kubeManager    *config.KubeConfigManager
        sessionManager *session.Manager
        clients        map[string]*kubernetes.Client

        // Estado da aplicação
        model *models.AppModel

        // UI Components
        width  int
        height int

        // Contexto
        ctx    context.Context
        cancel context.CancelFunc
}

// NewApp cria uma nova instância da aplicação
func NewApp(kubeconfigPath string, debug bool) *App <span class="cov0" title="0">{
        ctx, cancel := context.WithCancel(context.Background())

        return &amp;App{
                kubeconfigPath: kubeconfigPath,
                debug:          debug,
                clients:        make(map[string]*kubernetes.Client),
                ctx:            ctx,
                cancel:         cancel,
                model: &amp;models.AppModel{
                        State:           models.StateClusterDiscovery,
                        Loading:         false,
                        SelectedIndex:   0,
                        ActiveTab:       0,
                        ShowHelp:        false,
                        FormFields:      make(map[string]string),
                        AutoTimestamp:   true,
                        SessionTemplate: "{action}_{cluster}_{timestamp}",
                },
        }
}</span>

// Init implementa tea.Model interface
func (a *App) Init() tea.Cmd <span class="cov0" title="0">{
        return a.initializeManagers()
}</span>

// Update implementa tea.Model interface
func (a *App) Update(msg tea.Msg) (tea.Model, tea.Cmd) <span class="cov0" title="0">{
        switch msg := msg.(type) </span>{
        case tea.WindowSizeMsg:<span class="cov0" title="0">
                a.width = msg.Width
                a.height = msg.Height
                return a, nil</span>

        case tea.KeyMsg:<span class="cov0" title="0">
                return a.handleKeyPress(msg)</span>

        case initManagersMsg:<span class="cov0" title="0">
                if msg.err != nil </span><span class="cov0" title="0">{
                        a.model.Error = fmt.Sprintf("Failed to initialize: %v", msg.err)
                        return a, nil
                }</span>
                <span class="cov0" title="0">a.kubeManager = msg.kubeManager
                a.sessionManager = msg.sessionManager
                
                // Carregar sessões salvas automaticamente e descobrir clusters
                return a, tea.Batch(
                        a.loadSavedSessions(),
                        a.discoverClusters(),
                )</span>

        case clustersDiscoveredMsg:<span class="cov0" title="0">
                if msg.err != nil </span><span class="cov0" title="0">{
                        a.model.Error = fmt.Sprintf("Failed to discover clusters: %v", msg.err)
                        return a, nil
                }</span>
                <span class="cov0" title="0">a.model.Clusters = msg.clusters
                a.model.Loading = false
                return a, a.testClusterConnections()</span>

        case clusterConnectionTestMsg:<span class="cov0" title="0">
                a.updateClusterStatus(msg.cluster, msg.status, msg.err)
                return a, nil</span>

        case namespacesLoadedMsg:<span class="cov0" title="0">
                if msg.err != nil </span><span class="cov0" title="0">{
                        a.model.Error = fmt.Sprintf("Failed to load namespaces: %v", msg.err)
                        a.model.Loading = false
                        a.model.LoadingSessionData = false
                        return a, nil
                }</span>
                <span class="cov0" title="0">a.model.Namespaces = append(a.model.Namespaces, msg.namespaces...)
                
                // Se estamos carregando dados de sessão, carregar HPAs
                if a.model.LoadingSessionData &amp;&amp; a.model.CurrentSession != nil </span><span class="cov0" title="0">{
                        // Verificar se todos os namespaces foram carregados
                        expectedNamespaces := make(map[string]map[string]bool)
                        for _, change := range a.model.CurrentSession.Changes </span><span class="cov0" title="0">{
                                if expectedNamespaces[change.Cluster] == nil </span><span class="cov0" title="0">{
                                        expectedNamespaces[change.Cluster] = make(map[string]bool)
                                }</span>
                                <span class="cov0" title="0">expectedNamespaces[change.Cluster][change.Namespace] = true</span>
                        }
                        
                        <span class="cov0" title="0">loadedNamespaces := make(map[string]map[string]bool)
                        for _, ns := range a.model.Namespaces </span><span class="cov0" title="0">{
                                if loadedNamespaces[ns.Cluster] == nil </span><span class="cov0" title="0">{
                                        loadedNamespaces[ns.Cluster] = make(map[string]bool)
                                }</span>
                                <span class="cov0" title="0">loadedNamespaces[ns.Cluster][ns.Name] = true</span>
                        }
                        
                        // Verificar se todos os namespaces necessários foram carregados
                        <span class="cov0" title="0">allLoaded := true
                        for cluster, namespaces := range expectedNamespaces </span><span class="cov0" title="0">{
                                for namespace := range namespaces </span><span class="cov0" title="0">{
                                        if loadedNamespaces[cluster] == nil || !loadedNamespaces[cluster][namespace] </span><span class="cov0" title="0">{
                                                allLoaded = false
                                                break</span>
                                        }
                                }
                                <span class="cov0" title="0">if !allLoaded </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        
                        <span class="cov0" title="0">if allLoaded </span><span class="cov0" title="0">{
                                return a, a.loadSessionHPAs(a.model.CurrentSession)
                        }</span>
                } else<span class="cov0" title="0"> {
                        a.model.Loading = false
                        // Iniciar contagem assíncrona de HPAs
                        return a, a.countNamespaceHPAs()
                }</span>
                
                <span class="cov0" title="0">return a, nil</span>

        case namespacesHPACountMsg:<span class="cov0" title="0">
                if msg.err != nil </span><span class="cov0" title="0">{
                        // Ignorar erros de contagem de HPA - apenas deixa como 0
                        return a, nil
                }</span>
                // Atualizar contagem de HPAs para o namespace específico
                <span class="cov0" title="0">for i := range a.model.Namespaces </span><span class="cov0" title="0">{
                        if a.model.Namespaces[i].Cluster == msg.cluster &amp;&amp; a.model.Namespaces[i].Name == msg.namespace </span><span class="cov0" title="0">{
                                a.model.Namespaces[i].HPACount = msg.hpaCount
                                break</span>
                        }
                }
                <span class="cov0" title="0">return a, nil</span>

        case hpasLoadedMsg:<span class="cov0" title="0">
                if msg.err != nil </span><span class="cov0" title="0">{
                        a.model.Error = fmt.Sprintf("Failed to load HPAs: %v", msg.err)
                        if a.model.LoadingSessionData </span><span class="cov0" title="0">{
                                a.model.LoadingSessionData = false
                                a.model.Loading = false
                        }</span>
                        <span class="cov0" title="0">return a, nil</span>
                }
                <span class="cov0" title="0">a.model.HPAs = append(a.model.HPAs, msg.hpas...)
                
                // Se estamos carregando dados de sessão, verificar se todos os HPAs foram carregados
                if a.model.LoadingSessionData &amp;&amp; a.model.CurrentSession != nil </span><span class="cov0" title="0">{
                        // Verificar se todos os HPAs necessários foram carregados
                        expectedHPAs := make(map[string]map[string]map[string]bool)
                        for _, change := range a.model.CurrentSession.Changes </span><span class="cov0" title="0">{
                                if expectedHPAs[change.Cluster] == nil </span><span class="cov0" title="0">{
                                        expectedHPAs[change.Cluster] = make(map[string]map[string]bool)
                                }</span>
                                <span class="cov0" title="0">if expectedHPAs[change.Cluster][change.Namespace] == nil </span><span class="cov0" title="0">{
                                        expectedHPAs[change.Cluster][change.Namespace] = make(map[string]bool)
                                }</span>
                                <span class="cov0" title="0">expectedHPAs[change.Cluster][change.Namespace][change.HPAName] = true</span>
                        }
                        
                        <span class="cov0" title="0">loadedHPAs := make(map[string]map[string]map[string]bool)
                        for _, hpa := range a.model.HPAs </span><span class="cov0" title="0">{
                                if loadedHPAs[hpa.Cluster] == nil </span><span class="cov0" title="0">{
                                        loadedHPAs[hpa.Cluster] = make(map[string]map[string]bool)
                                }</span>
                                <span class="cov0" title="0">if loadedHPAs[hpa.Cluster][hpa.Namespace] == nil </span><span class="cov0" title="0">{
                                        loadedHPAs[hpa.Cluster][hpa.Namespace] = make(map[string]bool)
                                }</span>
                                <span class="cov0" title="0">loadedHPAs[hpa.Cluster][hpa.Namespace][hpa.Name] = true</span>
                        }
                        
                        // Verificar se todos os HPAs necessários foram carregados
                        <span class="cov0" title="0">allLoaded := true
                        for cluster, namespaces := range expectedHPAs </span><span class="cov0" title="0">{
                                for namespace, hpas := range namespaces </span><span class="cov0" title="0">{
                                        for hpaName := range hpas </span><span class="cov0" title="0">{
                                                if loadedHPAs[cluster] == nil || 
                                                   loadedHPAs[cluster][namespace] == nil || 
                                                   !loadedHPAs[cluster][namespace][hpaName] </span><span class="cov0" title="0">{
                                                        allLoaded = false
                                                        break</span>
                                                }
                                        }
                                        <span class="cov0" title="0">if !allLoaded </span><span class="cov0" title="0">{
                                                break</span>
                                        }
                                }
                                <span class="cov0" title="0">if !allLoaded </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        
                        <span class="cov0" title="0">if allLoaded </span><span class="cov0" title="0">{
                                a.model.LoadingSessionData = false
                                a.model.Loading = false
                                return a, a.applySessionChanges(a.model.CurrentSession)
                        }</span>
                }
                
                <span class="cov0" title="0">return a, nil</span>

        case sessionSavedMsg:<span class="cov0" title="0">
                if msg.err != nil </span><span class="cov0" title="0">{
                        a.model.Error = fmt.Sprintf("Failed to save session: %v", msg.err)
                        return a, nil
                }</span>
                <span class="cov0" title="0">a.model.CurrentSession = msg.session
                return a, nil</span>

        case sessionsListedMsg:<span class="cov0" title="0">
                if msg.err != nil </span><span class="cov0" title="0">{
                        // Erro silencioso no carregamento de sessões
                        return a, nil
                }</span>
                <span class="cov0" title="0">a.model.Sessions = msg.sessions
                return a, nil</span>

        case sessionLoadedMsg:<span class="cov0" title="0">
                if msg.err != nil </span><span class="cov0" title="0">{
                        a.model.Error = fmt.Sprintf("Failed to load session: %v", msg.err)
                        return a, nil
                }</span>
                <span class="cov0" title="0">a.model.CurrentSession = msg.session
                
                // Sempre carregar dados da sessão quando uma sessão é carregada
                return a, a.loadSessionData(msg.session)</span>

        case sessionDataLoadedMsg:<span class="cov0" title="0">
                if msg.err != nil </span><span class="cov0" title="0">{
                        a.model.Error = fmt.Sprintf("Failed to load session data: %v", msg.err)
                        return a, nil
                }</span>
                // Sessão carregada com sucesso - já transicionou para StateHPAManagement
                <span class="cov0" title="0">return a, nil</span>

        case operationCompletedMsg:<span class="cov0" title="0">
                a.updateOperationStatus(msg.operationID, msg.status, msg.err)
                return a, nil</span>
        }

        <span class="cov0" title="0">return a, nil</span>
}

// View implementa tea.Model interface
func (a *App) View() string <span class="cov0" title="0">{
        if a.width == 0 </span><span class="cov0" title="0">{
                return "Initializing..."
        }</span>

        // Mostrar tela de erro se houver
        <span class="cov0" title="0">if a.model.Error != "" </span><span class="cov0" title="0">{
                return a.renderErrorScreen()
        }</span>

        // Renderizar baseado no estado atual
        <span class="cov0" title="0">switch a.model.State </span>{
        case models.StateClusterDiscovery:<span class="cov0" title="0">
                return a.renderClusterDiscovery()</span>
        case models.StateNamespaceSelection:<span class="cov0" title="0">
                return a.renderNamespaceSelection()</span>
        case models.StateHPAManagement:<span class="cov0" title="0">
                return a.renderHPAManagement()</span>
        case models.StateHPAEditing:<span class="cov0" title="0">
                return a.renderHPAEditing()</span>
        case models.StateSessionManager:<span class="cov0" title="0">
                return a.renderSessionManager()</span>
        case models.StateOperationProgress:<span class="cov0" title="0">
                return a.renderOperationProgress()</span>
        default:<span class="cov0" title="0">
                return "Unknown state"</span>
        }
}

// handleKeyPress processa as teclas pressionadas
func (a *App) handleKeyPress(msg tea.KeyMsg) (tea.Model, tea.Cmd) <span class="cov0" title="0">{
        
        // Se estamos digitando nome da sessão, permitir entrada de texto
        if a.model.EnteringSessionName &amp;&amp; a.model.State == models.StateSessionManager </span><span class="cov0" title="0">{
                switch msg.String() </span>{
                case "ctrl+c":<span class="cov0" title="0">
                        a.cancel()
                        return a, tea.Quit</span>
                case "esc":<span class="cov0" title="0">
                        // Sair do modo de entrada de texto
                        a.model.EnteringSessionName = false
                        a.model.SessionName = ""
                        return a, nil</span>
                default:<span class="cov0" title="0">
                        // Delegar para handler do SessionManager (que processará texto ou ctrl+)
                        return a.handleSessionManagerKeys(msg)</span>
                }
        }

        <span class="cov0" title="0">switch msg.String() </span>{
        case "ctrl+c", "q":<span class="cov0" title="0">
                a.cancel()
                return a, tea.Quit</span>

        case "?":<span class="cov0" title="0">
                a.model.ShowHelp = !a.model.ShowHelp
                return a, nil</span>

        case "esc":<span class="cov0" title="0">
                // Voltar ao estado anterior ou fechar modal
                return a.handleEscape()</span>
        }

        // Delegar para handler específico baseado no estado
        <span class="cov0" title="0">switch a.model.State </span>{
        case models.StateClusterDiscovery:<span class="cov0" title="0">
                return a.handleClusterDiscoveryKeys(msg)</span>
        case models.StateNamespaceSelection:<span class="cov0" title="0">
                return a.handleNamespaceSelectionKeys(msg)</span>
        case models.StateHPAManagement:<span class="cov0" title="0">
                return a.handleHPAManagementKeys(msg)</span>
        case models.StateHPAEditing:<span class="cov0" title="0">
                return a.handleHPAEditingKeys(msg)</span>
        case models.StateSessionManager:<span class="cov0" title="0">
                return a.handleSessionManagerKeys(msg)</span>
        case models.StateOperationProgress:<span class="cov0" title="0">
                return a.handleOperationProgressKeys(msg)</span>
        }

        <span class="cov0" title="0">return a, nil</span>
}

// handleEscape lida com a tecla ESC
func (a *App) handleEscape() (tea.Model, tea.Cmd) <span class="cov0" title="0">{
        switch a.model.State </span>{
        case models.StateNamespaceSelection:<span class="cov0" title="0">
                a.model.State = models.StateClusterDiscovery
                a.model.SelectedIndex = 0</span>
        case models.StateHPAManagement:<span class="cov0" title="0">
                a.model.State = models.StateNamespaceSelection
                a.model.SelectedIndex = 0</span>
        case models.StateHPAEditing:<span class="cov0" title="0">
                a.model.State = models.StateHPAManagement
                a.model.EditingHPA = nil
                a.model.FormFields = make(map[string]string)</span>
        case models.StateSessionManager:<span class="cov0" title="0">
                // Voltar para o estado anterior
                if a.model.PreviousState != 0 </span><span class="cov0" title="0">{
                        a.model.State = a.model.PreviousState
                }</span> else<span class="cov0" title="0"> {
                        a.model.State = models.StateHPAManagement
                }</span>
        case models.StateOperationProgress:<span class="cov0" title="0">
                // Cancelar operações em progresso
                return a, a.cancelOperations()</span>
        }
        <span class="cov0" title="0">return a, nil</span>
}

// loadSavedSessions carrega as sessões salvas na inicialização
func (a *App) loadSavedSessions() tea.Cmd <span class="cov0" title="0">{
        if a.sessionManager == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return a.listSessions()</span>
}

// updateClusterStatus atualiza o status de um cluster
func (a *App) updateClusterStatus(clusterName string, status models.ConnectionStatus, err error) <span class="cov0" title="0">{
        for i := range a.model.Clusters </span><span class="cov0" title="0">{
                if a.model.Clusters[i].Name == clusterName </span><span class="cov0" title="0">{
                        a.model.Clusters[i].Status = status
                        if err != nil </span><span class="cov0" title="0">{
                                a.model.Clusters[i].Error = err.Error()
                        }</span>
                        <span class="cov0" title="0">break</span>
                }
        }
}

// updateOperationStatus atualiza o status de uma operação
func (a *App) updateOperationStatus(operationID string, status models.OperationStatus, err error) <span class="cov0" title="0">{
        for i := range a.model.Operations </span><span class="cov0" title="0">{
                if a.model.Operations[i].ID == operationID </span><span class="cov0" title="0">{
                        a.model.Operations[i].Status = status
                        if err != nil </span><span class="cov0" title="0">{
                                a.model.Operations[i].Error = err.Error()
                        }</span>
                        <span class="cov0" title="0">break</span>
                }
        }
}

// renderErrorScreen renderiza a tela de erro
func (a *App) renderErrorScreen() string <span class="cov0" title="0">{
        return fmt.Sprintf("❌ Erro: %s\n\nPressione 'q' para sair ou 'r' para tentar novamente.", a.model.Error)
}</pre>
		
		<pre class="file" id="file6" style="display: none">package tui

import (
        "fmt"
        "strings"
        "time"

        "k8s-hpa-manager/internal/models"

        "github.com/charmbracelet/lipgloss"
)

// Componentes modernos reutilizáveis

// StatusBadge cria um badge com status colorido
func StatusBadge(text string, status models.ConnectionStatus) string <span class="cov0" title="0">{
        var style lipgloss.Style

        switch status </span>{
        case models.StatusConnected:<span class="cov0" title="0">
                style = badgeSuccessStyle</span>
        case models.StatusError:<span class="cov0" title="0">
                style = badgeErrorStyle</span>
        case models.StatusTimeout:<span class="cov0" title="0">
                style = badgeWarningStyle</span>
        default:<span class="cov0" title="0">
                style = lipgloss.NewStyle().
                        Background(mutedColor).
                        Foreground(textColor).
                        Padding(0, 1)</span>
        }

        <span class="cov0" title="0">return style.Render(text)</span>
}

// MetricCard cria um card com métrica
func MetricCard(title, value, icon string, color lipgloss.Color) string <span class="cov0" title="0">{
        return cardStyle.Width(20).Render(
                lipgloss.NewStyle().
                        Foreground(color).
                        Bold(true).
                        Render(icon+" "+title) + "\n" +
                        value)
}</span>

// InfoPanel cria um painel de informações
func InfoPanel(title, content string, width int) string <span class="cov0" title="0">{
        header := lipgloss.NewStyle().
                Foreground(primaryColor).
                Bold(true).
                Render(title)

        return cardStyle.Width(width).Render(header + "\n\n" + content)
}</span>

// ActionButton cria um botão de ação
func ActionButton(key, action string, enabled bool) string <span class="cov0" title="0">{
        var style lipgloss.Style
        var prefix string

        if enabled </span><span class="cov0" title="0">{
                style = lipgloss.NewStyle().
                        Background(primaryColor).
                        Foreground(textColor).
                        Bold(true).
                        Padding(0, 1)
                prefix = "✅"
        }</span> else<span class="cov0" title="0"> {
                style = lipgloss.NewStyle().
                        Background(mutedColor).
                        Foreground(textMutedColor).
                        Padding(0, 1)
                prefix = "⚪"
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("%s %s", prefix, style.Render(fmt.Sprintf("[%s] %s", key, action)))</span>
}

// Timeline cria uma timeline de eventos
func Timeline(events []TimelineEvent) string <span class="cov0" title="0">{
        var items []string

        for i, event := range events </span><span class="cov0" title="0">{
                var connector string
                if i == 0 </span><span class="cov0" title="0">{
                        connector = "┌"
                }</span> else<span class="cov0" title="0"> if i == len(events)-1 </span><span class="cov0" title="0">{
                        connector = "└"
                }</span> else<span class="cov0" title="0"> {
                        connector = "├"
                }</span>

                <span class="cov0" title="0">var statusIcon string
                var timeStyle lipgloss.Style

                switch event.Status </span>{
                case "completed":<span class="cov0" title="0">
                        statusIcon = "✅"
                        timeStyle = lipgloss.NewStyle().Foreground(successColor)</span>
                case "failed":<span class="cov0" title="0">
                        statusIcon = "❌"
                        timeStyle = lipgloss.NewStyle().Foreground(errorColor)</span>
                case "in_progress":<span class="cov0" title="0">
                        statusIcon = "⏳"
                        timeStyle = lipgloss.NewStyle().Foreground(warningColor)</span>
                default:<span class="cov0" title="0">
                        statusIcon = "⚪"
                        timeStyle = normalItemStyle</span>
                }

                <span class="cov0" title="0">timeText := event.Time.Format("15:04:05")
                item := fmt.Sprintf("%s─ %s %s %s\n   %s",
                        connector,
                        statusIcon,
                        timeStyle.Render(timeText),
                        event.Title,
                        normalItemStyle.Render(event.Description))

                items = append(items, item)</span>
        }

        <span class="cov0" title="0">return strings.Join(items, "\n")</span>
}

// TimelineEvent representa um evento na timeline
type TimelineEvent struct {
        Time        time.Time
        Title       string
        Description string
        Status      string
}

// Table cria uma tabela moderna
func Table(headers []string, rows [][]string, highlightRow int) string <span class="cov0" title="0">{
        var content strings.Builder

        // Headers
        headerRow := make([]string, len(headers))
        for i, header := range headers </span><span class="cov0" title="0">{
                headerRow[i] = lipgloss.NewStyle().
                        Foreground(accentColor).
                        Bold(true).
                        Width(15).
                        Align(lipgloss.Center).
                        Render(header)
        }</span>
        <span class="cov0" title="0">content.WriteString(strings.Join(headerRow, " │ ") + "\n")

        // Separator
        separator := strings.Repeat("─", (15*len(headers))+(3*(len(headers)-1)))
        content.WriteString(separator + "\n")

        // Rows
        for i, row := range rows </span><span class="cov0" title="0">{
                displayRow := make([]string, len(row))
                var rowStyle lipgloss.Style

                if i == highlightRow </span><span class="cov0" title="0">{
                        rowStyle = selectedItemStyle
                }</span> else<span class="cov0" title="0"> {
                        rowStyle = normalItemStyle
                }</span>

                <span class="cov0" title="0">for j, cell := range row </span><span class="cov0" title="0">{
                        displayRow[j] = rowStyle.
                                Width(15).
                                Align(lipgloss.Center).
                                Render(cell)
                }</span>

                <span class="cov0" title="0">content.WriteString(strings.Join(displayRow, " │ ") + "\n")</span>
        }

        <span class="cov0" title="0">return content.String()</span>
}

// Notification cria uma notificação
func Notification(message, notificationType string) string <span class="cov0" title="0">{
        var style lipgloss.Style
        var icon string

        switch notificationType </span>{
        case "success":<span class="cov0" title="0">
                style = lipgloss.NewStyle().
                        Background(successColor).
                        Foreground(textColor).
                        Border(lipgloss.RoundedBorder()).
                        BorderForeground(successColor).
                        Padding(1, 2)
                icon = "✅"</span>
        case "error":<span class="cov0" title="0">
                style = lipgloss.NewStyle().
                        Background(errorColor).
                        Foreground(textColor).
                        Border(lipgloss.RoundedBorder()).
                        BorderForeground(errorColor).
                        Padding(1, 2)
                icon = "❌"</span>
        case "warning":<span class="cov0" title="0">
                style = lipgloss.NewStyle().
                        Background(warningColor).
                        Foreground(backgroundColor).
                        Border(lipgloss.RoundedBorder()).
                        BorderForeground(warningColor).
                        Padding(1, 2)
                icon = "⚠️"</span>
        default:<span class="cov0" title="0">
                style = lipgloss.NewStyle().
                        Background(primaryColor).
                        Foreground(textColor).
                        Border(lipgloss.RoundedBorder()).
                        BorderForeground(primaryColor).
                        Padding(1, 2)
                icon = "ℹ️"</span>
        }

        <span class="cov0" title="0">return style.Render(fmt.Sprintf("%s %s", icon, message))</span>
}

// LoadingSpinner cria um spinner de loading
func LoadingSpinner(message string, step int) string <span class="cov0" title="0">{
        spinners := []string{"⠋", "⠙", "⠹", "⠸", "⠼", "⠴", "⠦", "⠧", "⠇", "⠏"}
        spinner := spinners[step%len(spinners)]

        return lipgloss.NewStyle().
                Foreground(accentColor).
                Bold(true).
                Render(fmt.Sprintf("%s %s", spinner, message))
}</span>

// DiffView mostra diferenças entre valores
func DiffView(label string, oldValue, newValue interface{}, unit string) string <span class="cov0" title="0">{
        oldStr := fmt.Sprintf("%v", oldValue)
        newStr := fmt.Sprintf("%v", newValue)

        var changeIcon string
        var changeStyle lipgloss.Style

        if oldStr != newStr </span><span class="cov0" title="0">{
                // Tentar comparar como números se possível
                if oldInt, oldOk := oldValue.(int32); oldOk </span><span class="cov0" title="0">{
                        if newInt, newOk := newValue.(int32); newOk </span><span class="cov0" title="0">{
                                if newInt &gt; oldInt </span><span class="cov0" title="0">{
                                        changeIcon = "📈"
                                        changeStyle = lipgloss.NewStyle().Foreground(successColor)
                                }</span> else<span class="cov0" title="0"> {
                                        changeIcon = "📉"
                                        changeStyle = lipgloss.NewStyle().Foreground(warningColor)
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        changeIcon = "🔄"
                        changeStyle = lipgloss.NewStyle().Foreground(accentColor)
                }</span>
        } else<span class="cov0" title="0"> {
                changeIcon = "➡️"
                changeStyle = normalItemStyle
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("%s %s: %s%s → %s",
                changeIcon,
                label,
                oldStr,
                unit,
                changeStyle.Render(newStr+unit))</span>
}

// KeyValuePair cria um par chave-valor formatado
func KeyValuePair(key, value string, valueColor lipgloss.Color) string <span class="cov0" title="0">{
        keyStyle := lipgloss.NewStyle().
                Foreground(textMutedColor).
                Width(15).
                Align(lipgloss.Right)

        valueStyle := lipgloss.NewStyle().
                Foreground(valueColor).
                Bold(true)

        return fmt.Sprintf("%s: %s",
                keyStyle.Render(key),
                valueStyle.Render(value))
}</span>

// HelpModal cria um modal de ajuda
func HelpModal(title string, shortcuts []Shortcut, width, height int) string <span class="cov0" title="0">{
        var content strings.Builder

        // Título
        content.WriteString(
                lipgloss.NewStyle().
                        Foreground(primaryColor).
                        Bold(true).
                        Align(lipgloss.Center).
                        Width(width-4).
                        Render(title) + "\n\n")

        // Shortcuts
        for _, shortcut := range shortcuts </span><span class="cov0" title="0">{
                keyStyle := lipgloss.NewStyle().
                        Background(primaryColor).
                        Foreground(textColor).
                        Bold(true).
                        Padding(0, 1).
                        Width(12)

                descStyle := lipgloss.NewStyle().
                        Foreground(textColor)

                line := fmt.Sprintf("%s %s",
                        keyStyle.Render(shortcut.Key),
                        descStyle.Render(shortcut.Description))

                content.WriteString(line + "\n")
        }</span>

        // Footer
        <span class="cov0" title="0">content.WriteString("\n" +
                lipgloss.NewStyle().
                        Foreground(textMutedColor).
                        Italic(true).
                        Align(lipgloss.Center).
                        Width(width-4).
                        Render("Pressione ? novamente para fechar"))

        return lipgloss.NewStyle().
                Background(surfaceColor).
                Foreground(textColor).
                Border(lipgloss.RoundedBorder()).
                BorderForeground(primaryColor).
                Padding(2).
                Width(width).
                Height(height).
                Render(content.String())</span>
}

// Shortcut representa um atalho de teclado
type Shortcut struct {
        Key         string
        Description string
}

// Breadcrumb cria um breadcrumb de navegação
func Breadcrumb(items []string) string <span class="cov0" title="0">{
        if len(items) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">var breadcrumbItems []string

        for i, item := range items </span><span class="cov0" title="0">{
                var style lipgloss.Style

                if i == len(items)-1 </span><span class="cov0" title="0">{
                        // Último item (atual)
                        style = lipgloss.NewStyle().
                                Foreground(accentColor).
                                Bold(true)
                }</span> else<span class="cov0" title="0"> {
                        // Itens anteriores
                        style = lipgloss.NewStyle().
                                Foreground(textMutedColor)
                }</span>

                <span class="cov0" title="0">breadcrumbItems = append(breadcrumbItems, style.Render(item))</span>
        }

        <span class="cov0" title="0">return strings.Join(breadcrumbItems, " &gt; ")</span>
}

// AlertBox cria uma caixa de alerta
func AlertBox(title, message, alertType string, width int) string <span class="cov0" title="0">{
        var style lipgloss.Style
        var icon string

        switch alertType </span>{
        case "info":<span class="cov0" title="0">
                style = lipgloss.NewStyle().
                        Background(primaryColor).
                        Foreground(textColor).
                        Border(lipgloss.RoundedBorder()).
                        BorderForeground(primaryColor)
                icon = "ℹ️"</span>
        case "warning":<span class="cov0" title="0">
                style = lipgloss.NewStyle().
                        Background(warningColor).
                        Foreground(backgroundColor).
                        Border(lipgloss.RoundedBorder()).
                        BorderForeground(warningColor)
                icon = "⚠️"</span>
        case "error":<span class="cov0" title="0">
                style = lipgloss.NewStyle().
                        Background(errorColor).
                        Foreground(textColor).
                        Border(lipgloss.RoundedBorder()).
                        BorderForeground(errorColor)
                icon = "❌"</span>
        case "success":<span class="cov0" title="0">
                style = lipgloss.NewStyle().
                        Background(successColor).
                        Foreground(textColor).
                        Border(lipgloss.RoundedBorder()).
                        BorderForeground(successColor)
                icon = "✅"</span>
        default:<span class="cov0" title="0">
                style = cardStyle
                icon = "💬"</span>
        }

        <span class="cov0" title="0">headerText := fmt.Sprintf("%s %s", icon, title)
        content := headerText + "\n\n" + message

        return style.
                Width(width).
                Padding(1, 2).
                Render(content)</span>
}

// StatusIndicator cria um indicador de status circular
func StatusIndicator(status string) string <span class="cov0" title="0">{
        var color lipgloss.Color
        var symbol string

        switch status </span>{
        case "online", "connected", "active":<span class="cov0" title="0">
                color = successColor
                symbol = "●"</span>
        case "offline", "disconnected", "inactive":<span class="cov0" title="0">
                color = errorColor
                symbol = "●"</span>
        case "warning", "degraded":<span class="cov0" title="0">
                color = warningColor
                symbol = "●"</span>
        case "unknown", "pending":<span class="cov0" title="0">
                color = mutedColor
                symbol = "○"</span>
        default:<span class="cov0" title="0">
                color = mutedColor
                symbol = "○"</span>
        }

        <span class="cov0" title="0">return lipgloss.NewStyle().
                Foreground(color).
                Bold(true).
                Render(symbol)</span>
}

// PercentageBar cria uma barra de porcentagem
func PercentageBar(percentage float64, width int, showText bool) string <span class="cov0" title="0">{
        if percentage &gt; 100 </span><span class="cov0" title="0">{
                percentage = 100
        }</span>
        <span class="cov0" title="0">if percentage &lt; 0 </span><span class="cov0" title="0">{
                percentage = 0
        }</span>

        <span class="cov0" title="0">filled := int((percentage / 100) * float64(width))
        empty := width - filled

        var barColor lipgloss.Color
        if percentage &gt;= 80 </span><span class="cov0" title="0">{
                barColor = errorColor
        }</span> else<span class="cov0" title="0"> if percentage &gt;= 60 </span><span class="cov0" title="0">{
                barColor = warningColor
        }</span> else<span class="cov0" title="0"> {
                barColor = successColor
        }</span>

        <span class="cov0" title="0">filledPart := lipgloss.NewStyle().
                Background(barColor).
                Render(strings.Repeat(" ", filled))

        emptyPart := lipgloss.NewStyle().
                Background(mutedColor).
                Render(strings.Repeat(" ", empty))

        bar := filledPart + emptyPart

        if showText </span><span class="cov0" title="0">{
                text := fmt.Sprintf(" %.1f%%", percentage)
                return bar + lipgloss.NewStyle().
                        Foreground(textMutedColor).
                        Render(text)
        }</span>

        <span class="cov0" title="0">return bar</span>
}

// ModalOverlay cria um overlay para modals
func ModalOverlay(content string, width, height int) string <span class="cov0" title="0">{
        return lipgloss.Place(
                width, height,
                lipgloss.Center, lipgloss.Center,
                lipgloss.NewStyle().
                        Background(surfaceColor).
                        Foreground(textColor).
                        Border(lipgloss.RoundedBorder()).
                        BorderForeground(primaryColor).
                        Padding(2).
                        Render(content),
                lipgloss.WithWhitespaceChars("░"),
                lipgloss.WithWhitespaceForeground(lipgloss.Color("#333333")),
        )
}</span>

// QuickStats cria um painel de estatísticas rápidas
func QuickStats(stats map[string]interface{}) string <span class="cov0" title="0">{
        var items []string

        for label, value := range stats </span><span class="cov0" title="0">{
                var valueColor lipgloss.Color

                // Determinar cor baseada no tipo/valor
                switch v := value.(type) </span>{
                case int:<span class="cov0" title="0">
                        if v &gt; 0 </span><span class="cov0" title="0">{
                                valueColor = successColor
                        }</span> else<span class="cov0" title="0"> {
                                valueColor = mutedColor
                        }</span>
                case string:<span class="cov0" title="0">
                        if v == "online" || v == "connected" || v == "active" </span><span class="cov0" title="0">{
                                valueColor = successColor
                        }</span> else<span class="cov0" title="0"> if v == "offline" || v == "error" || v == "failed" </span><span class="cov0" title="0">{
                                valueColor = errorColor
                        }</span> else<span class="cov0" title="0"> {
                                valueColor = accentColor
                        }</span>
                default:<span class="cov0" title="0">
                        if fg := normalItemStyle.GetForeground(); fg != nil </span><span class="cov0" title="0">{
                                // Convert TerminalColor to lipgloss.Color safely
                                if colorStr, ok := fg.(lipgloss.Color); ok </span><span class="cov0" title="0">{
                                        valueColor = colorStr
                                }</span> else<span class="cov0" title="0"> {
                                        valueColor = textColor
                                }</span>
                        } else<span class="cov0" title="0"> {
                                valueColor = textColor
                        }</span>
                }

                <span class="cov0" title="0">item := KeyValuePair(label, fmt.Sprintf("%v", value), valueColor)
                items = append(items, item)</span>
        }

        <span class="cov0" title="0">return cardStyle.Render(strings.Join(items, "\n"))</span>
}

// EmptyState cria um estado vazio elegante
func EmptyState(icon, title, description string, width int) string <span class="cov0" title="0">{
        content := lipgloss.NewStyle().
                Foreground(textMutedColor).
                Align(lipgloss.Center).
                Width(width).
                Render(
                        lipgloss.NewStyle().
                                Foreground(mutedColor).
                                Render(icon) + "\n\n" +
                                lipgloss.NewStyle().
                                        Foreground(textColor).
                                        Bold(true).
                                        Render(title) + "\n\n" +
                                description)

        return cardStyle.Width(width).Render(content)
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package tui

import (
        "fmt"
        "strconv"
        "strings"

        "k8s-hpa-manager/internal/models"

        tea "github.com/charmbracelet/bubbletea"
)

// handleClusterDiscoveryKeys processa as teclas na tela de descoberta de clusters
func (a *App) handleClusterDiscoveryKeys(msg tea.KeyMsg) (tea.Model, tea.Cmd) <span class="cov0" title="0">{
        switch msg.String() </span>{
        case "up", "k":<span class="cov0" title="0">
                if a.model.SelectedIndex &gt; 0 </span><span class="cov0" title="0">{
                        a.model.SelectedIndex--
                }</span>
                <span class="cov0" title="0">return a, nil</span>

        case "down", "j":<span class="cov0" title="0">
                if a.model.SelectedIndex &lt; len(a.model.Clusters)-1 </span><span class="cov0" title="0">{
                        a.model.SelectedIndex++
                }</span>
                <span class="cov0" title="0">return a, nil</span>

        case " ", "enter":<span class="cov0" title="0">
                // Selecionar cluster único e entrar automaticamente
                if a.model.SelectedIndex &gt;= len(a.model.Clusters) </span><span class="cov0" title="0">{
                        return a, nil
                }</span>

                <span class="cov0" title="0">selectedCluster := &amp;a.model.Clusters[a.model.SelectedIndex]
                
                // Verificar se cluster está conectado
                if selectedCluster.Status != models.StatusConnected </span><span class="cov0" title="0">{
                        a.model.Error = fmt.Sprintf("Cluster %s não está conectado", selectedCluster.Name)
                        return a, nil
                }</span>

                // Limpar seleções anteriores e selecionar apenas este cluster
                <span class="cov0" title="0">for i := range a.model.Clusters </span><span class="cov0" title="0">{
                        a.model.Clusters[i].Selected = false
                }</span>
                <span class="cov0" title="0">selectedCluster.Selected = true

                // Entrar automaticamente no contexto do cluster
                a.model.State = models.StateNamespaceSelection
                a.model.SelectedIndex = 0
                a.model.Loading = true
                a.model.Error = ""
                a.model.Namespaces = nil // Limpar namespaces do cluster anterior
                
                return a, a.loadNamespaces()</span>

        case "r":<span class="cov0" title="0">
                // Refresh - testar conexões novamente
                a.model.Loading = true
                for i := range a.model.Clusters </span><span class="cov0" title="0">{
                        a.model.Clusters[i].Status = models.StatusUnknown
                        a.model.Clusters[i].Error = ""
                }</span>
                <span class="cov0" title="0">return a, a.testClusterConnections()</span>

        case "ctrl+s":<span class="cov0" title="0">
                // Abrir gerenciador de sessões salvas
                a.model.PreviousState = a.model.State
                a.model.State = models.StateSessionManager
                a.model.SelectedIndex = 0
                return a, a.listSessions()</span>

        }

        <span class="cov0" title="0">return a, nil</span>
}

// handleNamespaceSelectionKeys processa as teclas na tela de seleção de namespaces
func (a *App) handleNamespaceSelectionKeys(msg tea.KeyMsg) (tea.Model, tea.Cmd) <span class="cov0" title="0">{
        switch msg.String() </span>{
        case "up", "k":<span class="cov0" title="0">
                if a.model.SelectedIndex &gt; 0 </span><span class="cov0" title="0">{
                        a.model.SelectedIndex--
                }</span>
                <span class="cov0" title="0">return a, nil</span>

        case "down", "j":<span class="cov0" title="0">
                if a.model.SelectedIndex &lt; len(a.model.Namespaces)-1 </span><span class="cov0" title="0">{
                        a.model.SelectedIndex++
                }</span>
                <span class="cov0" title="0">return a, nil</span>

        case " ", "enter":<span class="cov0" title="0">
                // Selecionar namespace único e entrar automaticamente
                if a.model.SelectedIndex &gt;= len(a.model.Namespaces) </span><span class="cov0" title="0">{
                        return a, nil
                }</span>

                <span class="cov0" title="0">selectedNamespace := &amp;a.model.Namespaces[a.model.SelectedIndex]
                
                // Nota: Não verificamos HPACount aqui pois pode estar sendo carregado assincronamente

                // Limpar seleções anteriores e selecionar apenas este namespace
                for i := range a.model.Namespaces </span><span class="cov0" title="0">{
                        a.model.Namespaces[i].Selected = false
                }</span>
                <span class="cov0" title="0">selectedNamespace.Selected = true

                // Entrar automaticamente no gerenciamento de HPAs
                a.model.State = models.StateHPAManagement
                a.model.SelectedIndex = 0
                a.model.Loading = true
                a.model.Error = ""
                
                return a, a.loadHPAs()</span>


        case "f":<span class="cov0" title="0">
                // Filter: show only namespaces with HPAs
                var filtered []models.Namespace
                for _, ns := range a.model.Namespaces </span><span class="cov0" title="0">{
                        if ns.HPACount &gt; 0 </span><span class="cov0" title="0">{
                                filtered = append(filtered, ns)
                        }</span>
                }
                <span class="cov0" title="0">a.model.Namespaces = filtered
                if a.model.SelectedIndex &gt;= len(filtered) </span><span class="cov0" title="0">{
                        a.model.SelectedIndex = len(filtered) - 1
                }</span>
                <span class="cov0" title="0">return a, nil</span>

        case "s":<span class="cov0" title="0">
                // Toggle system namespaces visibility
                a.model.ShowSystemNamespaces = !a.model.ShowSystemNamespaces
                a.model.Loading = true
                a.model.SelectedIndex = 0
                a.model.Namespaces = nil // Limpar para recarregar com novo filtro
                return a, a.loadNamespaces()</span>
        }

        <span class="cov0" title="0">return a, nil</span>
}

// handleHPAManagementKeys processa as teclas na tela de gerenciamento de HPAs
func (a *App) handleHPAManagementKeys(msg tea.KeyMsg) (tea.Model, tea.Cmd) <span class="cov0" title="0">{
        switch msg.String() </span>{
        case "up", "k":<span class="cov0" title="0">
                if a.model.SelectedIndex &gt; 0 </span><span class="cov0" title="0">{
                        a.model.SelectedIndex--
                }</span>
                <span class="cov0" title="0">return a, nil</span>

        case "down", "j":<span class="cov0" title="0">
                if a.model.SelectedIndex &lt; len(a.model.HPAs)-1 </span><span class="cov0" title="0">{
                        a.model.SelectedIndex++
                }</span>
                <span class="cov0" title="0">return a, nil</span>

        case " ":<span class="cov0" title="0">
                // Toggle seleção do HPA atual
                if a.model.SelectedIndex &lt; len(a.model.HPAs) </span><span class="cov0" title="0">{
                        a.model.HPAs[a.model.SelectedIndex].Selected = !a.model.HPAs[a.model.SelectedIndex].Selected
                }</span>
                <span class="cov0" title="0">return a, nil</span>

        case "enter", "ctrl+e":<span class="cov0" title="0">
                // Editar HPA sob o cursor
                if a.model.SelectedIndex &lt; len(a.model.HPAs) </span><span class="cov0" title="0">{
                        hpa := &amp;a.model.HPAs[a.model.SelectedIndex]
                        
                        // Marcar o HPA como selecionado se ainda não estiver
                        if !hpa.Selected </span><span class="cov0" title="0">{
                                hpa.Selected = true
                        }</span>
                        
                        <span class="cov0" title="0">a.initializeHPAEditingFields(hpa)
                        a.model.State = models.StateHPAEditing</span>
                }
                <span class="cov0" title="0">return a, nil</span>

        case "ctrl+r":<span class="cov0" title="0">
                // Rollout dos HPAs selecionados
                var cmds []tea.Cmd
                for i := range a.model.HPAs </span><span class="cov0" title="0">{
                        if a.model.HPAs[i].Selected </span><span class="cov0" title="0">{
                                cmds = append(cmds, a.rolloutDeployment(&amp;a.model.HPAs[i]))
                        }</span>
                }

                <span class="cov0" title="0">if len(cmds) &gt; 0 </span><span class="cov0" title="0">{
                        a.model.State = models.StateOperationProgress
                        return a, tea.Batch(cmds...)
                }</span>
                <span class="cov0" title="0">return a, nil</span>

        case "ctrl+s":<span class="cov0" title="0">
                // Abrir gerenciador de sessões
                a.model.PreviousState = a.model.State
                a.model.State = models.StateSessionManager
                return a, a.listSessions()</span>

        case "ctrl+u":<span class="cov0" title="0">
                // Update HPAs selecionados e rollout se necessário
                var updateCmds []tea.Cmd
                var rolloutCmds []tea.Cmd
                
                for i := range a.model.HPAs </span><span class="cov0" title="0">{
                        if a.model.HPAs[i].Selected &amp;&amp; a.model.HPAs[i].Modified </span><span class="cov0" title="0">{
                                updateCmds = append(updateCmds, a.updateHPA(&amp;a.model.HPAs[i]))
                                
                                // Se PerformRollout está ativo, adicionar rollout após update
                                if a.model.PerformRollout </span><span class="cov0" title="0">{
                                        rolloutCmds = append(rolloutCmds, a.rolloutDeployment(&amp;a.model.HPAs[i]))
                                }</span>
                        }
                }

                <span class="cov0" title="0">if len(updateCmds) &gt; 0 </span><span class="cov0" title="0">{
                        // Executar updates primeiro, depois rollouts
                        allCmds := updateCmds
                        allCmds = append(allCmds, rolloutCmds...)
                        
                        a.model.State = models.StateOperationProgress
                        return a, tea.Batch(allCmds...)
                }</span>
                <span class="cov0" title="0">return a, nil</span>

        case "a":<span class="cov0" title="0">
                // Select all HPAs
                for i := range a.model.HPAs </span><span class="cov0" title="0">{
                        a.model.HPAs[i].Selected = true
                }</span>
                <span class="cov0" title="0">return a, nil</span>

        case "n":<span class="cov0" title="0">
                // Deselect all HPAs
                for i := range a.model.HPAs </span><span class="cov0" title="0">{
                        a.model.HPAs[i].Selected = false
                }</span>
                <span class="cov0" title="0">return a, nil</span>

        }

        <span class="cov0" title="0">return a, nil</span>
}

// handleHPAEditingKeys processa as teclas no modo de edição de HPA
func (a *App) handleHPAEditingKeys(msg tea.KeyMsg) (tea.Model, tea.Cmd) <span class="cov0" title="0">{
        if a.model.EditingHPA == nil </span><span class="cov0" title="0">{
                return a, nil
        }</span>

        <span class="cov0" title="0">switch msg.String() </span>{
        case "tab":<span class="cov0" title="0">
                // Alternar para próximo campo
                return a.navigateToNextField()</span>

        case "enter":<span class="cov0" title="0">
                // Aplicar mudanças
                return a.applyHPAChanges()</span>
                
        case " ":<span class="cov0" title="0">
                // Toggle rollout se estiver no campo de rollout
                if a.model.ActiveField == models.FieldRollout </span><span class="cov0" title="0">{
                        a.model.PerformRollout = !a.model.PerformRollout
                        if a.model.PerformRollout </span><span class="cov0" title="0">{
                                a.model.FormFields[models.FieldRollout] = "true"
                        }</span> else<span class="cov0" title="0"> {
                                a.model.FormFields[models.FieldRollout] = "false"
                        }</span>
                        <span class="cov0" title="0">return a, nil</span>
                }
                <span class="cov0" title="0">return a, nil</span>

        case "up", "k":<span class="cov0" title="0">
                // Incrementar valor do campo atual
                return a.incrementCurrentField(1)</span>

        case "down", "j":<span class="cov0" title="0">
                // Decrementar valor do campo atual
                return a.incrementCurrentField(-1)</span>

        case "ctrl+up":<span class="cov0" title="0">
                // Incrementar valor em 5
                return a.incrementCurrentField(5)</span>

        case "ctrl+down":<span class="cov0" title="0">
                // Decrementar valor em 5
                return a.incrementCurrentField(-5)</span>

        case "backspace":<span class="cov0" title="0">
                // Apagar último dígito do campo atual
                return a.handleNumericBackspace()</span>
                
        case "delete":<span class="cov0" title="0">
                // Delete tem o mesmo comportamento que backspace
                return a.handleNumericBackspace()</span>

        // Entrada numérica direta
        case "0", "1", "2", "3", "4", "5", "6", "7", "8", "9":<span class="cov0" title="0">
                return a.handleNumericInput(msg.String())</span>
        }

        <span class="cov0" title="0">return a, nil</span>
}

// handleSessionManagerKeys processa as teclas no gerenciador de sessões
func (a *App) handleSessionManagerKeys(msg tea.KeyMsg) (tea.Model, tea.Cmd) <span class="cov0" title="0">{
        switch msg.String() </span>{
        case "up", "k":<span class="cov0" title="0">
                if a.model.SelectedIndex &gt; 0 </span><span class="cov0" title="0">{
                        a.model.SelectedIndex--
                }</span>
                <span class="cov0" title="0">return a, nil</span>

        case "down", "j":<span class="cov0" title="0">
                if a.model.SelectedIndex &lt; len(a.model.Sessions)-1 </span><span class="cov0" title="0">{
                        a.model.SelectedIndex++
                }</span>
                <span class="cov0" title="0">return a, nil</span>

        case "ctrl+n":<span class="cov0" title="0">
                // Nova sessão - ativar modo de entrada de texto
                a.model.EnteringSessionName = true
                a.model.SessionName = "" // Limpar nome anterior
                return a, nil</span>
                
        case "ctrl+w":<span class="cov0" title="0">
                // Salvar sessão com nome digitado ou automático
                sessionName := a.model.SessionName
                if sessionName == "" </span><span class="cov0" title="0">{
                        sessionName = a.sessionManager.GenerateSessionName(
                                "manual-save",
                                a.model.SessionTemplate,
                                a.collectPendingChanges(),
                        )
                }</span>

                <span class="cov0" title="0">session := &amp;models.Session{
                        Name:        sessionName,
                        Description: "Manually saved session",
                        Changes:     a.collectPendingChanges(),
                }

                a.model.EnteringSessionName = false // Sair do modo de entrada se estiver
                a.model.SessionName = "" // Limpar nome
                return a, a.saveSession(session)</span>

        case "ctrl+l":<span class="cov0" title="0">
                // Carregar sessão selecionada
                if a.model.SelectedIndex &lt; len(a.model.Sessions) </span><span class="cov0" title="0">{
                        selectedSession := a.model.Sessions[a.model.SelectedIndex]
                        return a, a.loadSession(selectedSession.Name)
                }</span>
                <span class="cov0" title="0">return a, nil</span>

        case "ctrl+d":<span class="cov0" title="0">
                // Deletar sessão selecionada
                if a.model.SelectedIndex &lt; len(a.model.Sessions) </span><span class="cov0" title="0">{
                        selectedSession := a.model.Sessions[a.model.SelectedIndex]
                        return a, a.deleteSession(selectedSession.Name)
                }</span>
                <span class="cov0" title="0">return a, nil</span>

        case "ctrl+a":<span class="cov0" title="0">
                // Aplicar todas as mudanças da sessão atual
                if a.model.CurrentSession != nil </span><span class="cov0" title="0">{
                        var cmds []tea.Cmd
                        for _, change := range a.model.CurrentSession.Changes </span><span class="cov0" title="0">{
                                // Encontrar HPA correspondente e aplicar mudança
                                for i := range a.model.HPAs </span><span class="cov0" title="0">{
                                        hpa := &amp;a.model.HPAs[i]
                                        if hpa.Cluster == change.Cluster &amp;&amp;
                                                hpa.Namespace == change.Namespace &amp;&amp;
                                                hpa.Name == change.HPAName </span><span class="cov0" title="0">{

                                                // Aplicar valores da sessão
                                                hpa.MinReplicas = change.NewValues.MinReplicas
                                                hpa.MaxReplicas = change.NewValues.MaxReplicas
                                                hpa.Modified = true

                                                cmds = append(cmds, a.updateHPA(hpa))
                                                break</span>
                                        }
                                }
                        }

                        <span class="cov0" title="0">if len(cmds) &gt; 0 </span><span class="cov0" title="0">{
                                a.model.State = models.StateOperationProgress
                                return a, tea.Batch(cmds...)
                        }</span>
                }
                <span class="cov0" title="0">return a, nil</span>

        case "enter":<span class="cov0" title="0">
                // Se estamos no modo de entrada de texto, confirmar e salvar
                if a.model.EnteringSessionName </span><span class="cov0" title="0">{
                        sessionName := a.model.SessionName
                        if sessionName == "" </span><span class="cov0" title="0">{
                                sessionName = a.sessionManager.GenerateSessionName(
                                        "manual-save",
                                        a.model.SessionTemplate,
                                        a.collectPendingChanges(),
                                )
                        }</span>

                        <span class="cov0" title="0">session := &amp;models.Session{
                                Name:        sessionName,
                                Description: "Manually saved session",
                                Changes:     a.collectPendingChanges(),
                        }

                        a.model.EnteringSessionName = false // Sair do modo de entrada
                        return a, a.saveSession(session)</span>
                } else<span class="cov0" title="0"> {
                        // Se não estamos no modo de entrada, carregar sessão selecionada
                        if a.model.SelectedIndex &lt; len(a.model.Sessions) </span><span class="cov0" title="0">{
                                selectedSession := a.model.Sessions[a.model.SelectedIndex]
                                return a, a.loadSession(selectedSession.Name)
                        }</span>
                }
                <span class="cov0" title="0">return a, nil</span>

        case "backspace":<span class="cov0" title="0">
                // Tratar backspace para entrada de texto (apenas se estiver no modo de entrada)
                if a.model.EnteringSessionName </span><span class="cov0" title="0">{
                        return a.handleSessionNameInput(msg.String())
                }</span>
                <span class="cov0" title="0">return a, nil</span>
                
        case "delete":<span class="cov0" title="0">
                // Tratar delete para entrada de texto (apenas se estiver no modo de entrada)
                if a.model.EnteringSessionName </span><span class="cov0" title="0">{
                        return a.handleSessionNameInput("backspace")
                }</span>
                <span class="cov0" title="0">return a, nil</span>

        // Entrada de texto para nome da sessão (apenas se estiver no modo de entrada)
        default:<span class="cov0" title="0">
                if a.model.EnteringSessionName &amp;&amp; len(msg.String()) == 1 </span><span class="cov0" title="0">{
                        return a.handleSessionNameInput(msg.String())
                }</span>
        }

        <span class="cov0" title="0">return a, nil</span>
}

// handleOperationProgressKeys processa as teclas na tela de progresso
func (a *App) handleOperationProgressKeys(msg tea.KeyMsg) (tea.Model, tea.Cmd) <span class="cov0" title="0">{
        switch msg.String() </span>{
        case "enter":<span class="cov0" title="0">
                // Voltar ao gerenciamento de HPAs
                a.model.State = models.StateHPAManagement
                a.model.Operations = nil // Limpar operações
                return a, nil</span>
        }

        <span class="cov0" title="0">return a, nil</span>
}

// Funções auxiliares para edição

// applyHPAChanges aplica as mudanças no HPA sendo editado
func (a *App) applyHPAChanges() (tea.Model, tea.Cmd) <span class="cov0" title="0">{
        hpa := a.model.EditingHPA
        if hpa == nil </span><span class="cov0" title="0">{
                return a, nil
        }</span>

        // Aplicar valores dos campos do formulário
        <span class="cov0" title="0">if minStr, exists := a.model.FormFields["min_replicas"]; exists </span><span class="cov0" title="0">{
                if minVal, err := strconv.ParseInt(minStr, 10, 32); err == nil </span><span class="cov0" title="0">{
                        min := int32(minVal)
                        hpa.MinReplicas = &amp;min
                }</span>
        }

        <span class="cov0" title="0">if maxStr, exists := a.model.FormFields["max_replicas"]; exists </span><span class="cov0" title="0">{
                if maxVal, err := strconv.ParseInt(maxStr, 10, 32); err == nil </span><span class="cov0" title="0">{
                        hpa.MaxReplicas = int32(maxVal)
                }</span>
        }

        <span class="cov0" title="0">if cpuStr, exists := a.model.FormFields["target_cpu"]; exists </span><span class="cov0" title="0">{
                if cpuVal, err := strconv.ParseInt(cpuStr, 10, 32); err == nil </span><span class="cov0" title="0">{
                        cpu := int32(cpuVal)
                        hpa.TargetCPU = &amp;cpu
                }</span>
        }

        <span class="cov0" title="0">if memStr, exists := a.model.FormFields["target_memory"]; exists </span><span class="cov0" title="0">{
                if memVal, err := strconv.ParseInt(memStr, 10, 32); err == nil </span><span class="cov0" title="0">{
                        mem := int32(memVal)
                        hpa.TargetMemory = &amp;mem
                }</span>
        }

        // Marcar como modificado
        <span class="cov0" title="0">hpa.Modified = true

        // Voltar ao gerenciamento de HPAs
        a.model.State = models.StateHPAManagement
        a.model.EditingHPA = nil
        a.model.FormFields = make(map[string]string)

        return a, nil</span>
}

// incrementCurrentField incrementa/decrementa o valor do campo atual
func (a *App) incrementCurrentField(delta int) (tea.Model, tea.Cmd) <span class="cov0" title="0">{
        activeField := a.model.ActiveField
        if activeField == "" </span><span class="cov0" title="0">{
                activeField = models.FieldMinReplicas // Default para min_replicas
        }</span>
        
        // Campo de rollout não pode ser incrementado/decrementado
        <span class="cov0" title="0">if activeField == models.FieldRollout </span><span class="cov0" title="0">{
                return a, nil
        }</span>

        <span class="cov0" title="0">if currentStr, exists := a.model.FormFields[activeField]; exists </span><span class="cov0" title="0">{
                if currentVal, err := strconv.ParseInt(currentStr, 10, 32); err == nil </span><span class="cov0" title="0">{
                        newVal := int(currentVal) + delta
                        
                        // Aplicar validações baseadas no campo
                        switch activeField </span>{
                        case models.FieldMinReplicas:<span class="cov0" title="0">
                                if newVal &lt; 1 </span><span class="cov0" title="0">{
                                        newVal = 1
                                }</span>
                        case models.FieldMaxReplicas:<span class="cov0" title="0">
                                if newVal &lt; 1 </span><span class="cov0" title="0">{
                                        newVal = 1
                                }</span>
                        case models.FieldTargetCPU, models.FieldTargetMemory:<span class="cov0" title="0">
                                if newVal &lt; 1 </span><span class="cov0" title="0">{
                                        newVal = 1
                                }</span>
                                <span class="cov0" title="0">if newVal &gt; 100 </span><span class="cov0" title="0">{
                                        newVal = 100
                                }</span>
                        }
                        
                        <span class="cov0" title="0">a.model.FormFields[activeField] = fmt.Sprintf("%d", newVal)</span>
                }
        }

        <span class="cov0" title="0">return a, nil</span>
}

// handleNumericInput processa entrada numérica
func (a *App) handleNumericInput(digit string) (tea.Model, tea.Cmd) <span class="cov0" title="0">{
        activeField := a.model.ActiveField
        if activeField == "" </span><span class="cov0" title="0">{
                activeField = models.FieldMinReplicas // Default para min_replicas
        }</span>
        
        // Campo de rollout não aceita entrada numérica
        <span class="cov0" title="0">if activeField == models.FieldRollout </span><span class="cov0" title="0">{
                return a, nil
        }</span>

        <span class="cov0" title="0">if current, exists := a.model.FormFields[activeField]; exists </span><span class="cov0" title="0">{
                // Limitar a 3 dígitos para não causar overflow
                if len(current) &lt; 3 </span><span class="cov0" title="0">{
                        a.model.FormFields[activeField] = current + digit
                }</span>
        } else<span class="cov0" title="0"> {
                a.model.FormFields[activeField] = digit
        }</span>

        <span class="cov0" title="0">return a, nil</span>
}

// handleSessionNameInput processa entrada de texto para nome da sessão
func (a *App) handleSessionNameInput(char string) (tea.Model, tea.Cmd) <span class="cov0" title="0">{
        // Backspace primeiro
        if char == "backspace" &amp;&amp; len(a.model.SessionName) &gt; 0 </span><span class="cov0" title="0">{
                a.model.SessionName = a.model.SessionName[:len(a.model.SessionName)-1]
                return a, nil
        }</span>

        // Apenas caracteres únicos permitidos: a-z, A-Z, 0-9, _, -
        <span class="cov0" title="0">if len(char) == 1 &amp;&amp; strings.ContainsAny(char, "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_-") </span><span class="cov0" title="0">{
                if len(a.model.SessionName) &lt; 50 </span><span class="cov0" title="0">{
                        a.model.SessionName += char
                }</span>
        }

        <span class="cov0" title="0">return a, nil</span>
}

// handleNumericBackspace remove o último dígito do campo atual
func (a *App) handleNumericBackspace() (tea.Model, tea.Cmd) <span class="cov0" title="0">{
        activeField := a.model.ActiveField
        if activeField == "" </span><span class="cov0" title="0">{
                activeField = models.FieldMinReplicas // Default para min_replicas
        }</span>
        
        // Campo de rollout não aceita entrada numérica
        <span class="cov0" title="0">if activeField == models.FieldRollout </span><span class="cov0" title="0">{
                return a, nil
        }</span>

        <span class="cov0" title="0">if current, exists := a.model.FormFields[activeField]; exists &amp;&amp; len(current) &gt; 0 </span><span class="cov0" title="0">{
                // Remover último caractere
                a.model.FormFields[activeField] = current[:len(current)-1]
                
                // Se ficou vazio, colocar "0" como padrão
                if a.model.FormFields[activeField] == "" </span><span class="cov0" title="0">{
                        a.model.FormFields[activeField] = "0"
                }</span>
        }

        <span class="cov0" title="0">return a, nil</span>
}

// collectPendingChanges coleta todas as mudanças pendentes
func (a *App) collectPendingChanges() []models.HPAChange <span class="cov0" title="0">{
        var changes []models.HPAChange

        for _, hpa := range a.model.HPAs </span><span class="cov0" title="0">{
                if hpa.Modified </span><span class="cov0" title="0">{
                        change := models.HPAChange{
                                Cluster:        hpa.Cluster,
                                Namespace:      hpa.Namespace,
                                HPAName:        hpa.Name,
                                OriginalValues: hpa.OriginalValues,
                                NewValues: &amp;models.HPAValues{
                                        MinReplicas:  hpa.MinReplicas,
                                        MaxReplicas:  hpa.MaxReplicas,
                                        TargetCPU:    hpa.TargetCPU,
                                        TargetMemory: hpa.TargetMemory,
                                },
                        }
                        changes = append(changes, change)
                }</span>
        }

        <span class="cov0" title="0">return changes</span>
}

// navigateToNextField navega para o próximo campo editável
func (a *App) navigateToNextField() (tea.Model, tea.Cmd) <span class="cov0" title="0">{
        if a.model.EditingHPA == nil </span><span class="cov0" title="0">{
                return a, nil
        }</span>

        <span class="cov0" title="0">fields := []string{
                models.FieldMinReplicas,
                models.FieldMaxReplicas,
                models.FieldTargetCPU,
                models.FieldTargetMemory,
                models.FieldRollout,
        }

        currentIndex := 0
        for i, field := range fields </span><span class="cov0" title="0">{
                if a.model.ActiveField == field </span><span class="cov0" title="0">{
                        currentIndex = i
                        break</span>
                }
        }

        // Ir para o próximo campo (loop circular)
        <span class="cov0" title="0">nextIndex := (currentIndex + 1) % len(fields)
        a.model.ActiveField = fields[nextIndex]

        return a, nil</span>
}

// initializeHPAEditingFields inicializa os campos de edição do HPA
func (a *App) initializeHPAEditingFields(hpa *models.HPA) <span class="cov0" title="0">{
        a.model.EditingHPA = hpa
        a.model.ActiveField = models.FieldMinReplicas // Começar sempre pelo primeiro campo
        
        // Inicializar FormFields com valores atuais
        a.model.FormFields = make(map[string]string)
        
        if hpa.MinReplicas != nil </span><span class="cov0" title="0">{
                a.model.FormFields[models.FieldMinReplicas] = fmt.Sprintf("%d", *hpa.MinReplicas)
        }</span> else<span class="cov0" title="0"> {
                a.model.FormFields[models.FieldMinReplicas] = "1"
        }</span>
        
        <span class="cov0" title="0">a.model.FormFields[models.FieldMaxReplicas] = fmt.Sprintf("%d", hpa.MaxReplicas)
        
        if hpa.TargetCPU != nil </span><span class="cov0" title="0">{
                a.model.FormFields[models.FieldTargetCPU] = fmt.Sprintf("%d", *hpa.TargetCPU)
        }</span> else<span class="cov0" title="0"> {
                a.model.FormFields[models.FieldTargetCPU] = "80"
        }</span>
        
        <span class="cov0" title="0">if hpa.TargetMemory != nil </span><span class="cov0" title="0">{
                a.model.FormFields[models.FieldTargetMemory] = fmt.Sprintf("%d", *hpa.TargetMemory)
        }</span> else<span class="cov0" title="0"> {
                a.model.FormFields[models.FieldTargetMemory] = "80"
        }</span>
        
        // Inicializar rollout como false por padrão
        <span class="cov0" title="0">a.model.FormFields[models.FieldRollout] = "false"
        a.model.PerformRollout = false</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package tui

import (
        "fmt"

        tea "github.com/charmbracelet/bubbletea"

        "k8s-hpa-manager/internal/config"
        "k8s-hpa-manager/internal/kubernetes"
        "k8s-hpa-manager/internal/models"
        "k8s-hpa-manager/internal/session"
)

// Mensagens para inicialização
type initManagersMsg struct {
        kubeManager    *config.KubeConfigManager
        sessionManager *session.Manager
        err            error
}

// Mensagens para descoberta de clusters
type clustersDiscoveredMsg struct {
        clusters []models.Cluster
        err      error
}

type clusterConnectionTestMsg struct {
        cluster string
        status  models.ConnectionStatus
        err     error
}

// Mensagens para namespaces
type namespacesLoadedMsg struct {
        cluster    string
        namespaces []models.Namespace
        err        error
}

type namespacesHPACountMsg struct {
        cluster   string
        namespace string
        hpaCount  int
        err       error
}

// Mensagens para HPAs
type hpasLoadedMsg struct {
        cluster   string
        namespace string
        hpas      []models.HPA
        err       error
}

// Mensagens para operações
type operationStartedMsg struct {
        operation *models.Operation
}

type operationProgressMsg struct {
        operationID string
        progress    float64
        message     string
}

type operationCompletedMsg struct {
        operationID string
        status      models.OperationStatus
        err         error
}

// Mensagens para sessões
type sessionSavedMsg struct {
        session *models.Session
        err     error
}

type sessionLoadedMsg struct {
        session *models.Session
        err     error
}

type sessionsListedMsg struct {
        sessions []models.Session
        err      error
}

type sessionDataLoadedMsg struct {
        session *models.Session
        err     error
}

// Commands para inicialização
func (a *App) initializeManagers() tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                // Inicializar KubeConfigManager
                kubeManager, err := config.NewKubeConfigManager(a.kubeconfigPath)
                if err != nil </span><span class="cov0" title="0">{
                        return initManagersMsg{err: err}
                }</span>

                // Validar configuração
                <span class="cov0" title="0">if err := kubeManager.ValidateConfig(); err != nil </span><span class="cov0" title="0">{
                        return initManagersMsg{err: err}
                }</span>

                // Inicializar SessionManager
                <span class="cov0" title="0">sessionManager, err := session.NewManager()
                if err != nil </span><span class="cov0" title="0">{
                        return initManagersMsg{err: err}
                }</span>

                <span class="cov0" title="0">return initManagersMsg{
                        kubeManager:    kubeManager,
                        sessionManager: sessionManager,
                }</span>
        }
}

// Commands para descoberta de clusters
func (a *App) discoverClusters() tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                if a.kubeManager == nil </span><span class="cov0" title="0">{
                        return clustersDiscoveredMsg{err: fmt.Errorf("kube manager not initialized")}
                }</span>

                <span class="cov0" title="0">clusters := a.kubeManager.DiscoverClusters()
                return clustersDiscoveredMsg{clusters: clusters}</span>
        }
}

func (a *App) testClusterConnections() tea.Cmd <span class="cov0" title="0">{
        var cmds []tea.Cmd

        for _, cluster := range a.model.Clusters </span><span class="cov0" title="0">{
                cmds = append(cmds, a.testSingleClusterConnection(cluster.Name))
        }</span>

        <span class="cov0" title="0">return tea.Batch(cmds...)</span>
}

func (a *App) testSingleClusterConnection(clusterName string) tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                status := a.kubeManager.TestClusterConnection(a.ctx, clusterName)

                // Se conectado, criar cliente
                if status == models.StatusConnected </span><span class="cov0" title="0">{
                        clientset, err := a.kubeManager.GetClient(clusterName)
                        if err == nil </span><span class="cov0" title="0">{
                                client := kubernetes.NewClient(clientset, clusterName)
                                a.clients[clusterName] = client
                        }</span>
                }

                <span class="cov0" title="0">return clusterConnectionTestMsg{
                        cluster: clusterName,
                        status:  status,
                }</span>
        }
}

// Commands para carregamento de namespaces
func (a *App) loadNamespaces() tea.Cmd <span class="cov0" title="0">{
        var cmds []tea.Cmd

        for _, cluster := range a.model.Clusters </span><span class="cov0" title="0">{
                if cluster.Selected &amp;&amp; cluster.Status == models.StatusConnected </span><span class="cov0" title="0">{
                        cmds = append(cmds, a.loadNamespacesForCluster(cluster.Name))
                }</span>
        }

        <span class="cov0" title="0">return tea.Batch(cmds...)</span>
}

func (a *App) loadNamespacesForCluster(clusterName string) tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                client, exists := a.clients[clusterName]
                if !exists </span><span class="cov0" title="0">{
                        return namespacesLoadedMsg{
                                cluster: clusterName,
                                err:     fmt.Errorf("client not found for cluster %s", clusterName),
                        }
                }</span>

                <span class="cov0" title="0">namespaces, err := client.ListNamespaces(a.ctx, a.model.ShowSystemNamespaces)
                return namespacesLoadedMsg{
                        cluster:    clusterName,
                        namespaces: namespaces,
                        err:        err,
                }</span>
        }
}

// Commands para contagem assíncrona de HPAs em namespaces
func (a *App) countNamespaceHPAs() tea.Cmd <span class="cov0" title="0">{
        var cmds []tea.Cmd
        
        for _, ns := range a.model.Namespaces </span><span class="cov0" title="0">{
                cmds = append(cmds, a.countHPAsForNamespace(ns.Cluster, ns.Name))
        }</span>
        
        <span class="cov0" title="0">return tea.Batch(cmds...)</span>
}

func (a *App) countHPAsForNamespace(clusterName, namespaceName string) tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                client, exists := a.clients[clusterName]
                if !exists </span><span class="cov0" title="0">{
                        return namespacesHPACountMsg{
                                cluster:   clusterName,
                                namespace: namespaceName,
                                hpaCount:  0,
                                err:       fmt.Errorf("client not found for cluster %s", clusterName),
                        }
                }</span>

                <span class="cov0" title="0">hpaCount, err := client.CountHPAs(a.ctx, namespaceName)
                return namespacesHPACountMsg{
                        cluster:   clusterName,
                        namespace: namespaceName,
                        hpaCount:  hpaCount,
                        err:       err,
                }</span>
        }
}

// Commands para carregamento de HPAs
func (a *App) loadHPAs() tea.Cmd <span class="cov0" title="0">{
        var cmds []tea.Cmd

        for _, namespace := range a.model.Namespaces </span><span class="cov0" title="0">{
                if namespace.Selected </span><span class="cov0" title="0">{
                        cmds = append(cmds, a.loadHPAsForNamespace(namespace.Cluster, namespace.Name))
                }</span>
        }

        <span class="cov0" title="0">return tea.Batch(cmds...)</span>
}

func (a *App) loadHPAsForNamespace(clusterName, namespaceName string) tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                client, exists := a.clients[clusterName]
                if !exists </span><span class="cov0" title="0">{
                        return hpasLoadedMsg{
                                cluster:   clusterName,
                                namespace: namespaceName,
                                err:       fmt.Errorf("client not found for cluster %s", clusterName),
                        }
                }</span>

                <span class="cov0" title="0">hpas, err := client.ListHPAs(a.ctx, namespaceName)
                return hpasLoadedMsg{
                        cluster:   clusterName,
                        namespace: namespaceName,
                        hpas:      hpas,
                        err:       err,
                }</span>
        }
}

// Commands para operações com HPAs
func (a *App) updateHPA(hpa *models.HPA) tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                operation := &amp;models.Operation{
                        ID:      fmt.Sprintf("update-%s-%s-%s", hpa.Cluster, hpa.Namespace, hpa.Name),
                        Type:    "update_hpa",
                        Target:  fmt.Sprintf("%s/%s/%s", hpa.Cluster, hpa.Namespace, hpa.Name),
                        Status:  models.OpInProgress,
                        Message: "Updating HPA configuration...",
                }

                // Adicionar à lista de operações
                a.model.Operations = append(a.model.Operations, *operation)

                // Executar atualização
                client, exists := a.clients[hpa.Cluster]
                if !exists </span><span class="cov0" title="0">{
                        return operationCompletedMsg{
                                operationID: operation.ID,
                                status:      models.OpFailed,
                                err:         fmt.Errorf("client not found for cluster %s", hpa.Cluster),
                        }
                }</span>

                <span class="cov0" title="0">err := client.UpdateHPA(a.ctx, hpa)

                status := models.OpCompleted
                if err != nil </span><span class="cov0" title="0">{
                        status = models.OpFailed
                }</span>

                <span class="cov0" title="0">return operationCompletedMsg{
                        operationID: operation.ID,
                        status:      status,
                        err:         err,
                }</span>
        }
}

func (a *App) rolloutDeployment(hpa *models.HPA) tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                operation := &amp;models.Operation{
                        ID:      fmt.Sprintf("rollout-%s-%s-%s", hpa.Cluster, hpa.Namespace, hpa.Name),
                        Type:    "rollout",
                        Target:  fmt.Sprintf("%s/%s/%s", hpa.Cluster, hpa.Namespace, hpa.Name),
                        Status:  models.OpInProgress,
                        Message: "Rolling out deployment...",
                }

                // Adicionar à lista de operações
                a.model.Operations = append(a.model.Operations, *operation)

                client, exists := a.clients[hpa.Cluster]
                if !exists </span><span class="cov0" title="0">{
                        return operationCompletedMsg{
                                operationID: operation.ID,
                                status:      models.OpFailed,
                                err:         fmt.Errorf("client not found for cluster %s", hpa.Cluster),
                        }
                }</span>

                // Obter nome do deployment do HPA
                <span class="cov0" title="0">deploymentName, err := client.GetDeploymentFromHPA(a.ctx, hpa.Namespace, hpa.Name)
                if err != nil </span><span class="cov0" title="0">{
                        return operationCompletedMsg{
                                operationID: operation.ID,
                                status:      models.OpFailed,
                                err:         err,
                        }
                }</span>

                // Executar rollout
                <span class="cov0" title="0">err = client.RolloutDeployment(a.ctx, hpa.Namespace, deploymentName)

                status := models.OpCompleted
                if err != nil </span><span class="cov0" title="0">{
                        status = models.OpFailed
                }</span>

                <span class="cov0" title="0">return operationCompletedMsg{
                        operationID: operation.ID,
                        status:      status,
                        err:         err,
                }</span>
        }
}

// Commands para gerenciamento de sessões
func (a *App) saveSession(session *models.Session) tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                err := a.sessionManager.SaveSession(session)
                return sessionSavedMsg{
                        session: session,
                        err:     err,
                }
        }</span>
}

func (a *App) loadSession(sessionName string) tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                session, err := a.sessionManager.LoadSession(sessionName)
                return sessionLoadedMsg{
                        session: session,
                        err:     err,
                }
        }</span>
}

func (a *App) listSessions() tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                sessions, err := a.sessionManager.ListSessions()
                return sessionsListedMsg{
                        sessions: sessions,
                        err:      err,
                }
        }</span>
}

func (a *App) deleteSession(sessionName string) tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                err := a.sessionManager.DeleteSession(sessionName)
                if err != nil </span><span class="cov0" title="0">{
                        return sessionsListedMsg{err: err}
                }</span>

                // Recarregar lista de sessões
                <span class="cov0" title="0">sessions, err := a.sessionManager.ListSessions()
                return sessionsListedMsg{
                        sessions: sessions,
                        err:      err,
                }</span>
        }
}

// Commands utilitários
func (a *App) cancelOperations() tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                // Cancelar todas as operações em progresso
                for i := range a.model.Operations </span><span class="cov0" title="0">{
                        if a.model.Operations[i].Status == models.OpInProgress </span><span class="cov0" title="0">{
                                a.model.Operations[i].Status = models.OpCancelled
                        }</span>
                }

                <span class="cov0" title="0">return operationCompletedMsg{
                        operationID: "all",
                        status:      models.OpCancelled,
                }</span>
        }
}

func (a *App) createAutoSave() tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                // Coletar mudanças pendentes
                var changes []models.HPAChange
                for _, hpa := range a.model.HPAs </span><span class="cov0" title="0">{
                        if hpa.Modified </span><span class="cov0" title="0">{
                                change := models.HPAChange{
                                        Cluster:        hpa.Cluster,
                                        Namespace:      hpa.Namespace,
                                        HPAName:        hpa.Name,
                                        OriginalValues: hpa.OriginalValues,
                                        NewValues: &amp;models.HPAValues{
                                                MinReplicas:  hpa.MinReplicas,
                                                MaxReplicas:  hpa.MaxReplicas,
                                                TargetCPU:    hpa.TargetCPU,
                                                TargetMemory: hpa.TargetMemory,
                                        },
                                }
                                changes = append(changes, change)
                        }</span>
                }

                <span class="cov0" title="0">if len(changes) == 0 </span><span class="cov0" title="0">{
                        return sessionSavedMsg{err: fmt.Errorf("no changes to save")}
                }</span>

                <span class="cov0" title="0">session, err := a.sessionManager.CreateAutoSave(changes)
                return sessionSavedMsg{
                        session: session,
                        err:     err,
                }</span>
        }
}

// loadSessionData carrega os dados necessários para uma sessão
func (a *App) loadSessionData(session *models.Session) tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                // Verificar se há mudanças na sessão
                if len(session.Changes) == 0 </span><span class="cov0" title="0">{
                        return sessionDataLoadedMsg{
                                session: session,
                                err:     fmt.Errorf("sessão '%s' não tem mudanças para carregar", session.Name),
                        }
                }</span>
                
                // Marcar que estamos carregando dados de sessão
                <span class="cov0" title="0">a.model.LoadingSessionData = true
                a.model.Loading = true
                
                // Forçar redescoberta de clusters se não temos nenhum
                if len(a.model.Clusters) == 0 </span><span class="cov0" title="0">{
                        // Descobrir clusters primeiro
                        return sessionDataLoadedMsg{
                                session: session,
                                err:     fmt.Errorf("descobrindo clusters primeiro..."),
                        }
                }</span>
                
                // Limpar HPAs existentes
                <span class="cov0" title="0">a.model.HPAs = []models.HPA{}
                
                // Criar HPAs virtuais a partir das mudanças da sessão
                for _, change := range session.Changes </span><span class="cov0" title="0">{
                        // Criar HPA original (não modificado)
                        originalHPA := models.HPA{
                                Name:            change.HPAName,
                                Namespace:       change.Namespace,
                                Cluster:         change.Cluster,
                                MinReplicas:     change.OriginalValues.MinReplicas,
                                MaxReplicas:     change.OriginalValues.MaxReplicas,
                                TargetCPU:       change.OriginalValues.TargetCPU,
                                TargetMemory:    change.OriginalValues.TargetMemory,
                                OriginalValues:  change.OriginalValues,
                                Modified:        false,
                                Selected:        false,
                        }
                        
                        // Criar HPA modificado
                        modifiedHPA := models.HPA{
                                Name:            change.HPAName,
                                Namespace:       change.Namespace,
                                Cluster:         change.Cluster,
                                MinReplicas:     change.NewValues.MinReplicas,
                                MaxReplicas:     change.NewValues.MaxReplicas,
                                TargetCPU:       change.NewValues.TargetCPU,
                                TargetMemory:    change.NewValues.TargetMemory,
                                OriginalValues:  change.OriginalValues,
                                Modified:        true,
                                Selected:        true,
                        }
                        
                        // Adicionar ambos os HPAs
                        a.model.HPAs = append(a.model.HPAs, originalHPA, modifiedHPA)
                }</span>
                
                <span class="cov0" title="0">a.model.LoadingSessionData = false
                a.model.Loading = false
                a.model.State = models.StateHPAManagement
                a.model.SelectedIndex = 0
                
                return sessionDataLoadedMsg{
                        session: session,
                        err:     nil,
                }</span>
        }
}

// loadSessionHPAs carrega HPAs para todos os namespaces da sessão
func (a *App) loadSessionHPAs(session *models.Session) tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                // Extrair namespaces únicos das mudanças da sessão
                namespaceMap := make(map[string]map[string]bool)
                
                for _, change := range session.Changes </span><span class="cov0" title="0">{
                        if namespaceMap[change.Cluster] == nil </span><span class="cov0" title="0">{
                                namespaceMap[change.Cluster] = make(map[string]bool)
                        }</span>
                        <span class="cov0" title="0">namespaceMap[change.Cluster][change.Namespace] = true</span>
                }

                // Marcar namespaces como selecionados
                <span class="cov0" title="0">for i := range a.model.Namespaces </span><span class="cov0" title="0">{
                        ns := &amp;a.model.Namespaces[i]
                        if namespaceMap[ns.Cluster] != nil &amp;&amp; namespaceMap[ns.Cluster][ns.Name] </span><span class="cov0" title="0">{
                                ns.Selected = true
                        }</span>
                }

                // Carregar HPAs dos namespaces selecionados
                <span class="cov0" title="0">var cmds []tea.Cmd
                for clusterName, namespaces := range namespaceMap </span><span class="cov0" title="0">{
                        for namespaceName := range namespaces </span><span class="cov0" title="0">{
                                cmds = append(cmds, a.loadHPAsForNamespace(clusterName, namespaceName))
                        }</span>
                }

                <span class="cov0" title="0">return tea.Batch(cmds...)</span>
        }
}

// applySessionChanges aplica as mudanças da sessão aos HPAs carregados
func (a *App) applySessionChanges(session *models.Session) tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                // Aplicar mudanças aos HPAs
                for _, change := range session.Changes </span><span class="cov0" title="0">{
                        // Encontrar o HPA correspondente
                        for i := range a.model.HPAs </span><span class="cov0" title="0">{
                                hpa := &amp;a.model.HPAs[i]
                                if hpa.Cluster == change.Cluster &amp;&amp; 
                                   hpa.Namespace == change.Namespace &amp;&amp; 
                                   hpa.Name == change.HPAName </span><span class="cov0" title="0">{
                                        
                                        // Armazenar valores originais se ainda não foram salvos
                                        if hpa.OriginalValues == nil </span><span class="cov0" title="0">{
                                                hpa.OriginalValues = &amp;models.HPAValues{
                                                        MinReplicas:  hpa.MinReplicas,
                                                        MaxReplicas:  hpa.MaxReplicas,
                                                        TargetCPU:    hpa.TargetCPU,
                                                        TargetMemory: hpa.TargetMemory,
                                                }
                                        }</span>
                                        
                                        // Aplicar novos valores da sessão
                                        <span class="cov0" title="0">if change.NewValues != nil </span><span class="cov0" title="0">{
                                                hpa.MinReplicas = change.NewValues.MinReplicas
                                                hpa.MaxReplicas = change.NewValues.MaxReplicas
                                                hpa.TargetCPU = change.NewValues.TargetCPU
                                                hpa.TargetMemory = change.NewValues.TargetMemory
                                                hpa.Modified = true
                                                hpa.Selected = true
                                        }</span>
                                        <span class="cov0" title="0">break</span>
                                }
                        }
                }

                // Transicionar para o estado de gerenciamento de HPA
                <span class="cov0" title="0">a.model.State = models.StateHPAManagement
                a.model.SelectedIndex = 0

                return sessionDataLoadedMsg{
                        session: session,
                        err:     nil,
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package tui

import (
        "fmt"
        "strings"
        "time"

        "k8s-hpa-manager/internal/models"

        "github.com/charmbracelet/lipgloss"
)

// Exemplo de integração do novo layout moderno com o código existente

// ModernApp é uma extensão da App original com funcionalidades modernas
type ModernApp struct {
        *App
        theme         *ModernTheme
        layout        *ResponsiveLayout
        notifications []ModernNotification
        animations    *AnimationState
}

// ModernTheme define o tema visual
type ModernTheme struct {
        Primary    lipgloss.Color
        Secondary  lipgloss.Color
        Accent     lipgloss.Color
        Success    lipgloss.Color
        Warning    lipgloss.Color
        Error      lipgloss.Color
        Background lipgloss.Color
        Surface    lipgloss.Color
        Text       lipgloss.Color
        TextMuted  lipgloss.Color
}

// ResponsiveLayout gerencia o layout responsivo
type ResponsiveLayout struct {
        Width        int
        Height       int
        SidebarWidth int
        ContentWidth int
        CompactMode  bool
        TwoColumn    bool
}

// AnimationState gerencia animações simples
type AnimationState struct {
        Step        int
        LoadingText string
        PulseColors []lipgloss.Color
}

// NotificationMessage representa uma notificação
type NotificationMessage struct {
        ID      string
        Type    string
        Title   string
        Message string
        Timeout int
}

// NewModernApp cria uma nova instância com layout moderno
func NewModernApp(originalApp *App) *ModernApp <span class="cov0" title="0">{
        return &amp;ModernApp{
                App:   originalApp,
                theme: DefaultTheme(),
                layout: &amp;ResponsiveLayout{
                        SidebarWidth: 30,
                        CompactMode:  false,
                        TwoColumn:    true,
                },
                notifications: []ModernNotification{},
                animations: &amp;AnimationState{
                        Step:        0,
                        LoadingText: "Carregando",
                        PulseColors: []lipgloss.Color{
                                primaryColor,
                                secondaryColor,
                                accentColor,
                        },
                },
        }
}</span>

// DefaultTheme retorna o tema padrão
func DefaultTheme() *ModernTheme <span class="cov0" title="0">{
        return &amp;ModernTheme{
                Primary:    primaryColor,
                Secondary:  secondaryColor,
                Accent:     accentColor,
                Success:    successColor,
                Warning:    warningColor,
                Error:      errorColor,
                Background: backgroundColor,
                Surface:    surfaceColor,
                Text:       textColor,
                TextMuted:  textMutedColor,
        }
}</span>

// UpdateLayout atualiza o layout baseado no tamanho da tela
func (ma *ModernApp) UpdateLayout(width, height int) <span class="cov0" title="0">{
        ma.layout.Width = width
        ma.layout.Height = height

        // Determinar se deve usar modo compacto
        ma.layout.CompactMode = width &lt; 100 || height &lt; 30

        // Ajustar largura da sidebar
        if ma.layout.CompactMode </span><span class="cov0" title="0">{
                ma.layout.SidebarWidth = 25
                ma.layout.TwoColumn = false
        }</span> else<span class="cov0" title="0"> {
                ma.layout.SidebarWidth = 30
                ma.layout.TwoColumn = width &gt; 120
        }</span>

        <span class="cov0" title="0">ma.layout.ContentWidth = width - ma.layout.SidebarWidth - 6</span>
}

// RenderWithModernLayout renderiza usando o layout moderno
func (ma *ModernApp) RenderWithModernLayout() string <span class="cov0" title="0">{
        // Atualizar animações
        ma.animations.Step++

        // Renderizar notificações
        notifications := ma.renderNotifications()

        // Renderizar conteúdo principal baseado no estado
        var mainContent string

        switch ma.App.model.State </span>{
        case models.StateClusterDiscovery:<span class="cov0" title="0">
                mainContent = ma.renderModernClusterDiscovery()</span>
        case models.StateNamespaceSelection:<span class="cov0" title="0">
                mainContent = ma.renderModernNamespaceSelection()</span>
        case models.StateHPAManagement:<span class="cov0" title="0">
                mainContent = ma.renderModernHPAManagement()</span>
        case models.StateHPAEditing:<span class="cov0" title="0">
                mainContent = ma.renderModernHPAEditing()</span>
        case models.StateSessionManager:<span class="cov0" title="0">
                mainContent = ma.renderModernSessionManager()</span>
        case models.StateOperationProgress:<span class="cov0" title="0">
                mainContent = ma.renderModernOperationProgress()</span>
        default:<span class="cov0" title="0">
                mainContent = "Estado desconhecido"</span>
        }

        // Combinar tudo
        <span class="cov0" title="0">var content strings.Builder

        if len(notifications) &gt; 0 </span><span class="cov0" title="0">{
                content.WriteString(notifications + "\n")
        }</span>

        <span class="cov0" title="0">content.WriteString(mainContent)

        // Adicionar modal de ajuda se ativo
        if ma.App.model.ShowHelp </span><span class="cov0" title="0">{
                helpModal := ma.renderHelpModal()
                return ModalOverlay(helpModal, ma.layout.Width, ma.layout.Height)
        }</span>

        <span class="cov0" title="0">return content.String()</span>
}

// renderModernClusterDiscovery renderiza descoberta de clusters com layout moderno
func (ma *ModernApp) renderModernClusterDiscovery() string <span class="cov0" title="0">{
        // Usar o método original mas com enhancements
        baseContent := ma.App.renderClusterDiscovery()

        // Adicionar estatísticas dinâmicas
        stats := map[string]interface{}{
                "Total":      len(ma.App.model.Clusters),
                "Conectados": ma.countConnectedClusters(),
                "Sessões":    len(ma.App.model.Sessions),
                "Status":     ma.getOverallStatus(),
        }

        statsPanel := QuickStats(stats)

        // Adicionar loading spinner se necessário
        if ma.App.model.Loading </span><span class="cov0" title="0">{
                spinner := LoadingSpinner("Testando conexões", ma.animations.Step)
                return baseContent + "\n" + spinner + "\n" + statsPanel
        }</span>

        <span class="cov0" title="0">return baseContent + "\n" + statsPanel</span>
}

// renderModernNamespaceSelection renderiza seleção de namespaces com enhancements
func (ma *ModernApp) renderModernNamespaceSelection() string <span class="cov0" title="0">{
        baseContent := ma.App.renderNamespaceSelection()

        // Adicionar filtros visuais
        filterStatus := ma.renderFilterStatus()

        // Timeline de ações recentes
        timeline := ma.renderRecentActionsTimeline()

        return baseContent + "\n" + filterStatus + "\n" + timeline
}</span>

// renderNotifications renderiza notificações ativas
func (ma *ModernApp) renderNotifications() string <span class="cov0" title="0">{
        if len(ma.notifications) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">var notificationItems []string

        for _, notification := range ma.notifications </span><span class="cov0" title="0">{
                notificationItems = append(notificationItems,
                        Notification(notification.Message, notification.Type))
        }</span>

        <span class="cov0" title="0">return lipgloss.JoinVertical(lipgloss.Left, notificationItems...)</span>
}

// renderHelpModal renderiza o modal de ajuda moderno
func (ma *ModernApp) renderHelpModal() string <span class="cov0" title="0">{
        var shortcuts []Shortcut

        // Shortcuts baseados no estado atual
        switch ma.App.model.State </span>{
        case models.StateClusterDiscovery:<span class="cov0" title="0">
                shortcuts = []Shortcut{
                        {"↑↓", "Navegar pela lista"},
                        {"ENTER", "Conectar ao cluster"},
                        {"R", "Atualizar conexões"},
                        {"Ctrl+S", "Gerenciar sessões"},
                        {"Q", "Sair da aplicação"},
                }</span>
        case models.StateNamespaceSelection:<span class="cov0" title="0">
                shortcuts = []Shortcut{
                        {"↑↓", "Navegar namespaces"},
                        {"ENTER", "Selecionar namespace"},
                        {"F", "Filtrar com HPAs"},
                        {"S", "Toggle namespaces sistema"},
                        {"ESC", "Voltar aos clusters"},
                }</span>
        case models.StateHPAManagement:<span class="cov0" title="0">
                shortcuts = []Shortcut{
                        {"↑↓", "Navegar HPAs"},
                        {"SPACE", "Selecionar/deselecionar"},
                        {"ENTER", "Editar HPA"},
                        {"Ctrl+U", "Aplicar mudanças"},
                        {"Ctrl+R", "Rollout deployments"},
                        {"Ctrl+S", "Salvar sessão"},
                        {"A", "Selecionar todos"},
                        {"N", "Deselecionar todos"},
                        {"ESC", "Voltar aos namespaces"},
                }</span>
        case models.StateHPAEditing:<span class="cov0" title="0">
                shortcuts = []Shortcut{
                        {"TAB", "Próximo campo"},
                        {"↑↓", "Ajustar valor (±1)"},
                        {"Ctrl+↑↓", "Ajustar valor (±5)"},
                        {"0-9", "Entrada numérica"},
                        {"SPACE", "Toggle rollout"},
                        {"ENTER", "Aplicar mudanças"},
                        {"ESC", "Cancelar edição"},
                }</span>
        case models.StateSessionManager:<span class="cov0" title="0">
                shortcuts = []Shortcut{
                        {"↑↓", "Navegar sessões"},
                        {"ENTER", "Carregar sessão"},
                        {"Ctrl+N", "Nova sessão"},
                        {"Ctrl+W", "Salvar sessão"},
                        {"Ctrl+D", "Deletar sessão"},
                        {"Ctrl+A", "Aplicar todas mudanças"},
                        {"ESC", "Voltar"},
                }</span>
        case models.StateOperationProgress:<span class="cov0" title="0">
                shortcuts = []Shortcut{
                        {"ENTER", "Continuar"},
                        {"ESC", "Cancelar operações"},
                }</span>
        }

        // Shortcuts globais
        <span class="cov0" title="0">globalShortcuts := []Shortcut{
                {"?", "Mostrar/ocultar ajuda"},
                {"Ctrl+C", "Sair"},
        }

        shortcuts = append(shortcuts, globalShortcuts...)

        return HelpModal("💡 Atalhos de Teclado", shortcuts, 60, 25)</span>
}

// renderFilterStatus renderiza o status dos filtros ativos
func (ma *ModernApp) renderFilterStatus() string <span class="cov0" title="0">{
        var filters []string

        if !ma.App.model.ShowSystemNamespaces </span><span class="cov0" title="0">{
                filters = append(filters, "🚫 Namespaces sistema ocultos")
        }</span>

        // Adicionar outros filtros conforme necessário
        <span class="cov0" title="0">totalNS := len(ma.App.model.Namespaces)
        withHPAs := 0
        for _, ns := range ma.App.model.Namespaces </span><span class="cov0" title="0">{
                if ns.HPACount &gt; 0 </span><span class="cov0" title="0">{
                        withHPAs++
                }</span>
        }

        <span class="cov0" title="0">if withHPAs &gt; 0 </span><span class="cov0" title="0">{
                filters = append(filters, fmt.Sprintf("🎯 %d/%d com HPAs", withHPAs, totalNS))
        }</span>

        <span class="cov0" title="0">if len(filters) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">return InfoPanel("🔍 Filtros Ativos", strings.Join(filters, "\n"), 40)</span>
}

// renderRecentActionsTimeline renderiza timeline de ações recentes
func (ma *ModernApp) renderRecentActionsTimeline() string <span class="cov0" title="0">{
        // Mock de eventos recentes - em implementação real,
        // isso viria de um log de ações do usuário
        events := []TimelineEvent{
                {
                        Time:        time.Now().Add(-2 * time.Minute),
                        Title:       "Cluster conectado",
                        Description: "akspriv-prod-central",
                        Status:      "completed",
                },
                {
                        Time:        time.Now().Add(-1 * time.Minute),
                        Title:       "Namespace selecionado",
                        Description: "api-services",
                        Status:      "completed",
                },
                {
                        Time:        time.Now(),
                        Title:       "Carregando HPAs",
                        Description: "Descobrindo recursos...",
                        Status:      "in_progress",
                },
        }

        timelineContent := Timeline(events)
        return InfoPanel("📈 Atividade Recente", timelineContent, 50)
}</span>

// countConnectedClusters conta clusters conectados
func (ma *ModernApp) countConnectedClusters() int <span class="cov0" title="0">{
        count := 0
        for _, cluster := range ma.App.model.Clusters </span><span class="cov0" title="0">{
                if cluster.Status == models.StatusConnected </span><span class="cov0" title="0">{
                        count++
                }</span>
        }
        <span class="cov0" title="0">return count</span>
}

// getOverallStatus retorna o status geral do sistema
func (ma *ModernApp) getOverallStatus() string <span class="cov0" title="0">{
        if ma.App.model.Loading </span><span class="cov0" title="0">{
                return "Carregando"
        }</span>

        <span class="cov0" title="0">connected := ma.countConnectedClusters()
        total := len(ma.App.model.Clusters)

        if connected == 0 </span><span class="cov0" title="0">{
                return "Desconectado"
        }</span> else<span class="cov0" title="0"> if connected == total </span><span class="cov0" title="0">{
                return "Online"
        }</span> else<span class="cov0" title="0"> {
                return "Parcial"
        }</span>
}

// AddNotification adiciona uma notificação
func (ma *ModernApp) AddNotification(message, notificationType string) <span class="cov0" title="0">{
        notification := ModernNotification{
                ID:      fmt.Sprintf("notif_%d", time.Now().UnixNano()),
                Type:    notificationType,
                Message: message,
                Timeout: 5, // 5 segundos
        }

        ma.notifications = append(ma.notifications, notification)

        // Limitar número de notificações
        if len(ma.notifications) &gt; 3 </span><span class="cov0" title="0">{
                ma.notifications = ma.notifications[1:]
        }</span>
}

// ClearNotifications limpa todas as notificações
func (ma *ModernApp) ClearNotifications() <span class="cov0" title="0">{
        ma.notifications = []ModernNotification{}
}</span>

// Notification representa uma notificação na tela
type ModernNotification struct {
        ID      string
        Type    string
        Message string
        Timeout int
}

// renderEnhancedHPATable renderiza uma tabela melhorada de HPAs
func (ma *ModernApp) renderEnhancedHPATable() string <span class="cov0" title="0">{
        if len(ma.App.model.HPAs) == 0 </span><span class="cov0" title="0">{
                return EmptyState(
                        "🎯",
                        "Nenhum HPA Encontrado",
                        "Este namespace não possui HPAs configurados",
                        60,
                )
        }</span>

        <span class="cov0" title="0">headers := []string{"Nome", "Min", "Max", "Current", "CPU", "Status"}
        var rows [][]string

        for _, hpa := range ma.App.model.HPAs </span><span class="cov0" title="0">{
                var status string
                if hpa.Modified </span><span class="cov0" title="0">{
                        status = "Modificado"
                }</span> else<span class="cov0" title="0"> if hpa.Selected </span><span class="cov0" title="0">{
                        status = "Selecionado"
                }</span> else<span class="cov0" title="0"> {
                        status = "Normal"
                }</span>

                <span class="cov0" title="0">cpu := "N/A"
                if hpa.TargetCPU != nil </span><span class="cov0" title="0">{
                        cpu = fmt.Sprintf("%d%%", *hpa.TargetCPU)
                }</span>

                <span class="cov0" title="0">row := []string{
                        truncateString(hpa.Name, 15),
                        fmt.Sprintf("%d", getIntValue(hpa.MinReplicas)),
                        fmt.Sprintf("%d", hpa.MaxReplicas),
                        fmt.Sprintf("%d", hpa.CurrentReplicas),
                        cpu,
                        status,
                }

                rows = append(rows, row)</span>
        }

        <span class="cov0" title="0">return Table(headers, rows, ma.App.model.SelectedIndex)</span>
}

// renderResourceUtilization renderiza utilização de recursos
func (ma *ModernApp) renderResourceUtilization() string <span class="cov0" title="0">{
        var content strings.Builder

        content.WriteString(
                lipgloss.NewStyle().
                        Foreground(primaryColor).
                        Bold(true).
                        Render("📊 Utilização de Recursos") + "\n\n")

        // Calcular utilização total
        totalMinReplicas := int32(0)
        totalMaxReplicas := int32(0)
        totalCurrentReplicas := int32(0)

        for _, hpa := range ma.App.model.HPAs </span><span class="cov0" title="0">{
                totalMinReplicas += getIntValue(hpa.MinReplicas)
                totalMaxReplicas += hpa.MaxReplicas
                totalCurrentReplicas += hpa.CurrentReplicas
        }</span>

        // Calcular percentual de utilização
        <span class="cov0" title="0">var utilizationPercent float64
        if totalMaxReplicas &gt; 0 </span><span class="cov0" title="0">{
                utilizationPercent = (float64(totalCurrentReplicas) / float64(totalMaxReplicas)) * 100
        }</span>

        <span class="cov0" title="0">content.WriteString(fmt.Sprintf("Min Replicas: %d\n", totalMinReplicas))
        content.WriteString(fmt.Sprintf("Max Replicas: %d\n", totalMaxReplicas))
        content.WriteString(fmt.Sprintf("Current: %d\n", totalCurrentReplicas))
        content.WriteString("Utilização: " + PercentageBar(utilizationPercent, 30, true) + "\n")

        return cardStyle.Width(40).Render(content.String())</span>
}

// renderClusterHealth renderiza saúde do cluster
func (ma *ModernApp) renderClusterHealth() string <span class="cov0" title="0">{
        var content strings.Builder

        content.WriteString(
                lipgloss.NewStyle().
                        Foreground(accentColor).
                        Bold(true).
                        Render("💚 Saúde do Cluster") + "\n\n")

        // Status dos clusters
        for _, cluster := range ma.App.model.Clusters </span><span class="cov0" title="0">{
                if cluster.Selected </span><span class="cov0" title="0">{
                        statusIndicator := StatusIndicator(cluster.Status.String())
                        content.WriteString(fmt.Sprintf("%s %s\n", statusIndicator, cluster.Name))

                        // Detalhes adicionais baseados no status
                        switch cluster.Status </span>{
                        case models.StatusConnected:<span class="cov0" title="0">
                                content.WriteString("  ✅ Conexão estável\n")</span>
                        case models.StatusError:<span class="cov0" title="0">
                                content.WriteString("  ❌ Erro de conexão\n")
                                if cluster.Error != "" </span><span class="cov0" title="0">{
                                        content.WriteString(fmt.Sprintf("  💬 %s\n", cluster.Error))
                                }</span>
                        case models.StatusTimeout:<span class="cov0" title="0">
                                content.WriteString("  ⏱️ Timeout na conexão\n")</span>
                        default:<span class="cov0" title="0">
                                content.WriteString("  ⏳ Verificando...\n")</span>
                        }
                }
        }

        <span class="cov0" title="0">return cardStyle.Width(40).Render(content.String())</span>
}

// GetLayoutInfo retorna informações sobre o layout atual
func (ma *ModernApp) GetLayoutInfo() *ResponsiveLayout <span class="cov0" title="0">{
        return ma.layout
}</span>

// GetTheme retorna o tema atual
func (ma *ModernApp) GetTheme() *ModernTheme <span class="cov0" title="0">{
        return ma.theme
}</span>

// SetTheme define um novo tema
func (ma *ModernApp) SetTheme(theme *ModernTheme) <span class="cov0" title="0">{
        ma.theme = theme
        // Atualizar cores globais
        primaryColor = theme.Primary
        secondaryColor = theme.Secondary
        accentColor = theme.Accent
        successColor = theme.Success
        warningColor = theme.Warning
        errorColor = theme.Error
        backgroundColor = theme.Background
        surfaceColor = theme.Surface
        textColor = theme.Text
        textMutedColor = theme.TextMuted
}</span>

// Exemplo de uso da integração:
/*
func main() {
    // Criar app original
    originalApp := tui.NewApp(kubeconfigPath, debug)

    // Criar versão moderna
    modernApp := tui.NewModernApp(originalApp)

    // Configurar programa Bubble Tea
    p := tea.NewProgram(modernApp, tea.WithAltScreen())

    // Executar
    if _, err := p.Run(); err != nil {
        log.Fatal(err)
    }
}
*/

// renderModernHPAManagement implementa a versão moderna do gerenciamento de HPAs
func (ma *ModernApp) renderModernHPAManagement() string <span class="cov0" title="0">{
        var content strings.Builder

        // Header moderno
        header := ma.App.renderModernHeader("🎯 Gerenciamento de HPAs", "Controle de Auto-scaling")
        content.WriteString(header + "\n")

        // Layout principal
        if ma.layout.TwoColumn </span><span class="cov0" title="0">{
                // Layout de duas colunas para telas grandes
                leftColumn := ma.App.renderHPAsSidebar()
                rightColumn := ma.renderEnhancedRightPanel()

                mainContent := lipgloss.JoinHorizontal(lipgloss.Top, leftColumn, rightColumn)
                content.WriteString(mainContent)
        }</span> else<span class="cov0" title="0"> {
                // Layout compacto para telas pequenas
                compactContent := ma.renderCompactHPAView()
                content.WriteString(compactContent)
        }</span>

        // Footer com ações
        <span class="cov0" title="0">footer := ma.App.renderActionFooter([]string{
                "↑↓ Navegar", "SPACE Selecionar", "ENTER Editar",
                "Ctrl+U Aplicar", "Ctrl+S Sessões",
        })
        content.WriteString("\n" + footer)

        return content.String()</span>
}

// renderEnhancedRightPanel renderiza painel direito melhorado
func (ma *ModernApp) renderEnhancedRightPanel() string <span class="cov0" title="0">{
        var panels []string

        // Painel de detalhes do HPA selecionado
        if ma.App.model.SelectedIndex &lt; len(ma.App.model.HPAs) </span><span class="cov0" title="0">{
                selectedHPA := ma.App.model.HPAs[ma.App.model.SelectedIndex]
                hpaDetails := ma.App.renderSelectedHPADetails(selectedHPA)
                panels = append(panels, hpaDetails)
        }</span>

        // Painel de utilização de recursos
        <span class="cov0" title="0">resourcePanel := ma.renderResourceUtilization()
        panels = append(panels, resourcePanel)

        // Painel de saúde do cluster
        healthPanel := ma.renderClusterHealth()
        panels = append(panels, healthPanel)

        return lipgloss.JoinVertical(lipgloss.Left, panels...)</span>
}

// renderCompactHPAView renderiza visualização compacta para telas pequenas
func (ma *ModernApp) renderCompactHPAView() string <span class="cov0" title="0">{
        // Implementação simplificada para telas pequenas
        return ma.renderEnhancedHPATable()
}</span>

// renderModernHPAEditing implementa edição moderna
func (ma *ModernApp) renderModernHPAEditing() string <span class="cov0" title="0">{
        return ma.App.renderHPAEditing() // Usar implementação existente por agora
}</span>

// renderModernSessionManager implementa gerenciamento de sessão moderno
func (ma *ModernApp) renderModernSessionManager() string <span class="cov0" title="0">{
        return ma.App.renderSessionManager() // Usar implementação existente por agora
}</span>

// renderModernOperationProgress implementa progresso de operação moderno
func (ma *ModernApp) renderModernOperationProgress() string <span class="cov0" title="0">{
        return ma.App.renderOperationProgress() // Usar implementação existente por agora
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package tui

import (
        "fmt"
        "strconv"
        "strings"
        "time"

        "k8s-hpa-manager/internal/models"

        "github.com/charmbracelet/lipgloss"
)

// Cores e tema moderno
var (
        // Paleta de cores principal
        primaryColor     = lipgloss.Color("#6366f1") // Indigo
        secondaryColor   = lipgloss.Color("#8b5cf6") // Violet
        accentColor      = lipgloss.Color("#06b6d4") // Cyan
        successColor     = lipgloss.Color("#10b981") // Emerald
        warningColor     = lipgloss.Color("#f59e0b") // Amber
        errorColor       = lipgloss.Color("#ef4444") // Red
        mutedColor       = lipgloss.Color("#6b7280") // Gray
        backgroundColor  = lipgloss.Color("#0f172a") // Slate 900
        surfaceColor     = lipgloss.Color("#1e293b") // Slate 800
        textColor        = lipgloss.Color("#f1f5f9") // Slate 100
        textMutedColor   = lipgloss.Color("#94a3b8") // Slate 400

        // Layout responsivo
        maxWidth = 120
        sidebarWidth = 30
)

// Estilos modernos com glassmorphism
var (
        // Header principal com cor sólida (gradiente não suportado na versão atual)
        headerStyle = lipgloss.NewStyle().
                Background(primaryColor).
                Foreground(textColor).
                Bold(true).
                Padding(1, 2).
                MarginBottom(1)

        // Painel principal com glassmorphism
        panelStyle = lipgloss.NewStyle().
                Background(surfaceColor).
                Foreground(textColor).
                Border(lipgloss.RoundedBorder()).
                BorderForeground(primaryColor).
                Padding(1, 2).
                MarginRight(1).
                MarginBottom(1)

        // Sidebar estilo
        sidebarStyle = lipgloss.NewStyle().
                Background(surfaceColor).
                Foreground(textColor).
                Border(lipgloss.RoundedBorder()).
                BorderForeground(accentColor).
                Padding(1, 2).
                Width(sidebarWidth - 4)

        // Item selecionado com destaque moderno
        selectedItemStyle = lipgloss.NewStyle().
                Background(primaryColor).
                Foreground(textColor).
                Bold(true).
                Padding(0, 1).
                MarginRight(1)

        // Item normal
        normalItemStyle = lipgloss.NewStyle().
                Foreground(textMutedColor).
                Padding(0, 1).
                MarginRight(1)

        // Item com status
        statusConnectedStyle = lipgloss.NewStyle().
                Foreground(successColor).
                Bold(true)

        statusErrorStyle = lipgloss.NewStyle().
                Foreground(errorColor).
                Bold(true)

        statusWarningStyle = lipgloss.NewStyle().
                Foreground(warningColor).
                Bold(true)

        // Cards modernos
        cardStyle = lipgloss.NewStyle().
                Background(surfaceColor).
                Foreground(textColor).
                Border(lipgloss.RoundedBorder()).
                BorderForeground(mutedColor).
                Padding(1, 2).
                MarginRight(1).
                MarginBottom(1)

        // Badges e indicadores
        badgeSuccessStyle = lipgloss.NewStyle().
                Background(successColor).
                Foreground(textColor).
                Bold(true).
                Padding(0, 1).
                MarginLeft(1)

        badgeWarningStyle = lipgloss.NewStyle().
                Background(warningColor).
                Foreground(backgroundColor).
                Bold(true).
                Padding(0, 1).
                MarginLeft(1)

        badgeErrorStyle = lipgloss.NewStyle().
                Background(errorColor).
                Foreground(textColor).
                Bold(true).
                Padding(0, 1).
                MarginLeft(1)

        // Progress bar
        progressBarStyle = lipgloss.NewStyle().
                Background(mutedColor).
                Foreground(textColor)

        progressFillStyle = lipgloss.NewStyle().
                Background(primaryColor).
                Foreground(textColor)

        // Texto de ajuda moderno
        helpTextStyle = lipgloss.NewStyle().
                Foreground(textMutedColor).
                Italic(true).
                MarginTop(1)

        // Input field
        inputStyle = lipgloss.NewStyle().
                Background(backgroundColor).
                Foreground(textColor).
                Border(lipgloss.RoundedBorder()).
                BorderForeground(accentColor).
                Padding(0, 1)

        inputFocusedStyle = lipgloss.NewStyle().
                Background(backgroundColor).
                Foreground(textColor).
                Border(lipgloss.RoundedBorder()).
                BorderForeground(primaryColor).
                Padding(0, 1).
                Bold(true)
)

// renderClusterDiscovery - Layout moderno dashboard style
func (a *App) renderClusterDiscovery() string <span class="cov0" title="0">{
        var content strings.Builder

        // Header principal com breadcrumb
        header := a.renderModernHeader("🏠 Dashboard", "Descoberta de Clusters")
        content.WriteString(header + "\n")

        // Layout em duas colunas
        leftColumn := a.renderClustersSidebar()
        rightColumn := a.renderClusterDetails()

        // Combinar colunas
        mainContent := lipgloss.JoinHorizontal(
                lipgloss.Top,
                leftColumn,
                rightColumn,
        )

        content.WriteString(mainContent)

        // Footer com ações
        footer := a.renderActionFooter([]string{
                "↑↓ Navegar",
                "ENTER Conectar",
                "R Refresh",
                "Ctrl+S Sessões",
                "Q Sair",
        })
        content.WriteString("\n" + footer)

        return content.String()
}</span>

// renderClustersSidebar - Sidebar com lista de clusters
func (a *App) renderClustersSidebar() string <span class="cov0" title="0">{
        var items []string

        // Header da sidebar
        items = append(items, 
                lipgloss.NewStyle().
                        Foreground(accentColor).
                        Bold(true).
                        Render("🔍 Clusters Disponíveis"))
        items = append(items, "")

        // Lista de clusters
        for i, cluster := range a.model.Clusters </span><span class="cov0" title="0">{
                var icon, status string
                var statusStyle lipgloss.Style

                // Ícones e status
                switch cluster.Status </span>{
                case models.StatusConnected:<span class="cov0" title="0">
                        icon = "✅"
                        status = "Online"
                        statusStyle = statusConnectedStyle</span>
                case models.StatusTimeout:<span class="cov0" title="0">
                        icon = "⏱️"
                        status = "Timeout"
                        statusStyle = statusWarningStyle</span>
                case models.StatusError:<span class="cov0" title="0">
                        icon = "❌"
                        status = "Error"
                        statusStyle = statusErrorStyle</span>
                default:<span class="cov0" title="0">
                        icon = "⏳"
                        status = "Checking"
                        statusStyle = normalItemStyle</span>
                }

                // Nome do cluster truncado
                <span class="cov0" title="0">clusterName := truncateString(cluster.Name, 20)
                
                // Item da lista
                itemText := fmt.Sprintf("%s %s", icon, clusterName)
                statusText := statusStyle.Render(status)

                var item string
                if i == a.model.SelectedIndex </span><span class="cov0" title="0">{
                        item = selectedItemStyle.Render("▶ " + itemText) + " " + statusText
                }</span> else<span class="cov0" title="0"> {
                        item = normalItemStyle.Render("  " + itemText) + " " + statusText
                }</span>

                <span class="cov0" title="0">items = append(items, item)</span>
        }

        <span class="cov0" title="0">if len(a.model.Clusters) == 0 &amp;&amp; a.model.Loading </span><span class="cov0" title="0">{
                items = append(items, normalItemStyle.Render("  🔄 Carregando..."))
        }</span>

        <span class="cov0" title="0">content := strings.Join(items, "\n")
        return sidebarStyle.Render(content)</span>
}

// renderClusterDetails - Painel principal com detalhes
func (a *App) renderClusterDetails() string <span class="cov0" title="0">{
        var content strings.Builder

        // Cards de estatísticas
        statsCards := a.renderStatsCards()
        content.WriteString(statsCards + "\n")

        // Detalhes do cluster selecionado
        if a.model.SelectedIndex &lt; len(a.model.Clusters) </span><span class="cov0" title="0">{
                selectedCluster := a.model.Clusters[a.model.SelectedIndex]
                clusterDetails := a.renderSelectedClusterDetails(selectedCluster)
                content.WriteString(clusterDetails + "\n")
        }</span>

        // Sessões recentes
        <span class="cov0" title="0">if len(a.model.Sessions) &gt; 0 </span><span class="cov0" title="0">{
                recentSessions := a.renderRecentSessions()
                content.WriteString(recentSessions)
        }</span>

        <span class="cov0" title="0">return panelStyle.Width(maxWidth - sidebarWidth - 6).Render(content.String())</span>
}

// renderStatsCards - Cards com estatísticas
func (a *App) renderStatsCards() string <span class="cov0" title="0">{
        connected := 0
        total := len(a.model.Clusters)
        sessions := len(a.model.Sessions)

        for _, cluster := range a.model.Clusters </span><span class="cov0" title="0">{
                if cluster.Status == models.StatusConnected </span><span class="cov0" title="0">{
                        connected++
                }</span>
        }

        // Card de clusters
        <span class="cov0" title="0">clusterCard := cardStyle.Width(20).Render(
                statusConnectedStyle.Render("🏗️  Clusters") + "\n" +
                fmt.Sprintf("%d/%d Online", connected, total))

        // Card de sessões
        sessionCard := cardStyle.Width(20).Render(
                lipgloss.NewStyle().Foreground(accentColor).Bold(true).Render("💾 Sessões") + "\n" +
                fmt.Sprintf("%d Salvas", sessions))

        // Card de status
        var statusText string
        var statusColor lipgloss.Color
        if a.model.Loading </span><span class="cov0" title="0">{
                statusText = "Carregando..."
                statusColor = warningColor
        }</span> else<span class="cov0" title="0"> if connected == total &amp;&amp; total &gt; 0 </span><span class="cov0" title="0">{
                statusText = "Tudo OK"
                statusColor = successColor
        }</span> else<span class="cov0" title="0"> {
                statusText = "Verificando"
                statusColor = warningColor
        }</span>

        <span class="cov0" title="0">statusCard := cardStyle.Width(20).Render(
                lipgloss.NewStyle().Foreground(statusColor).Bold(true).Render("📊 Status") + "\n" +
                statusText)

        return lipgloss.JoinHorizontal(lipgloss.Top, clusterCard, sessionCard, statusCard)</span>
}

// renderSelectedClusterDetails - Detalhes do cluster selecionado
func (a *App) renderSelectedClusterDetails(cluster models.Cluster) string <span class="cov0" title="0">{
        var content strings.Builder

        content.WriteString(
                lipgloss.NewStyle().
                        Foreground(primaryColor).
                        Bold(true).
                        Render("🎯 Cluster Selecionado") + "\n\n")

        // Nome e contexto
        content.WriteString(fmt.Sprintf("📛 Nome: %s\n", cluster.Name))
        content.WriteString(fmt.Sprintf("🔗 Contexto: %s\n", cluster.Context))

        // Status detalhado
        var statusIcon string
        var statusText string
        var statusStyle lipgloss.Style

        switch cluster.Status </span>{
        case models.StatusConnected:<span class="cov0" title="0">
                statusIcon = "✅"
                statusText = "Conectado e pronto para uso"
                statusStyle = statusConnectedStyle</span>
        case models.StatusTimeout:<span class="cov0" title="0">
                statusIcon = "⏱️"
                statusText = "Timeout na conexão"
                statusStyle = statusWarningStyle</span>
        case models.StatusError:<span class="cov0" title="0">
                statusIcon = "❌"
                statusText = "Erro na conexão"
                statusStyle = statusErrorStyle
                if cluster.Error != "" </span><span class="cov0" title="0">{
                        statusText += fmt.Sprintf(": %s", cluster.Error)
                }</span>
        default:<span class="cov0" title="0">
                statusIcon = "⏳"
                statusText = "Testando conectividade..."
                statusStyle = normalItemStyle</span>
        }

        <span class="cov0" title="0">content.WriteString(fmt.Sprintf("🔌 Status: %s %s\n", 
                statusIcon, 
                statusStyle.Render(statusText)))

        // Ações disponíveis
        if cluster.Status == models.StatusConnected </span><span class="cov0" title="0">{
                content.WriteString("\n" + lipgloss.NewStyle().Foreground(successColor).Render("🚀 Pronto para conectar!"))
        }</span>

        <span class="cov0" title="0">return cardStyle.Width(maxWidth - sidebarWidth - 10).Render(content.String())</span>
}

// renderRecentSessions - Sessões recentes
func (a *App) renderRecentSessions() string <span class="cov0" title="0">{
        var items []string

        items = append(items, 
                lipgloss.NewStyle().
                        Foreground(accentColor).
                        Bold(true).
                        Render("📚 Sessões Recentes"))
        items = append(items, "")

        // Mostrar até 3 sessões mais recentes
        maxSessions := 3
        if len(a.model.Sessions) &lt; maxSessions </span><span class="cov0" title="0">{
                maxSessions = len(a.model.Sessions)
        }</span>

        <span class="cov0" title="0">for i := 0; i &lt; maxSessions; i++ </span><span class="cov0" title="0">{
                session := a.model.Sessions[i]
                
                // Calcular idade
                age := "hoje"
                if !session.CreatedAt.IsZero() </span><span class="cov0" title="0">{
                        duration := time.Since(session.CreatedAt)
                        if duration.Hours() &gt; 24 </span><span class="cov0" title="0">{
                                age = fmt.Sprintf("%.0f dias", duration.Hours()/24)
                        }</span> else<span class="cov0" title="0"> if duration.Hours() &gt; 1 </span><span class="cov0" title="0">{
                                age = fmt.Sprintf("%.0fh", duration.Hours())
                        }</span> else<span class="cov0" title="0"> {
                                age = fmt.Sprintf("%.0fm", duration.Minutes())
                        }</span>
                }

                <span class="cov0" title="0">hpaCount := len(session.Changes)
                sessionText := fmt.Sprintf("💾 %s (%d HPAs, %s)", 
                        truncateString(session.Name, 25), hpaCount, age)
                
                items = append(items, normalItemStyle.Render("  " + sessionText))</span>
        }

        <span class="cov0" title="0">if len(a.model.Sessions) == 0 </span><span class="cov0" title="0">{
                items = append(items, normalItemStyle.Render("  Nenhuma sessão salva"))
        }</span>

        <span class="cov0" title="0">content := strings.Join(items, "\n")
        return cardStyle.Width(maxWidth - sidebarWidth - 10).Render(content)</span>
}

// renderNamespaceSelection - Layout moderno para seleção de namespaces
func (a *App) renderNamespaceSelection() string <span class="cov0" title="0">{
        var content strings.Builder

        // Header com breadcrumb
        selectedCluster := ""
        for _, cluster := range a.model.Clusters </span><span class="cov0" title="0">{
                if cluster.Selected </span><span class="cov0" title="0">{
                        selectedCluster = cluster.Name
                        break</span>
                }
        }

        <span class="cov0" title="0">header := a.renderModernHeader("🏠 Dashboard &gt; 📁 Namespaces", 
                fmt.Sprintf("Cluster: %s", selectedCluster))
        content.WriteString(header + "\n")

        // Layout em duas colunas
        leftColumn := a.renderNamespacesSidebar()
        rightColumn := a.renderNamespaceDetails()

        mainContent := lipgloss.JoinHorizontal(
                lipgloss.Top,
                leftColumn,
                rightColumn,
        )

        content.WriteString(mainContent)

        // Footer com ações
        actions := []string{
                "↑↓ Navegar",
                "ENTER Selecionar",
                "F Filtrar HPAs",
                "S Toggle Sistema",
                "ESC Voltar",
        }

        if a.model.ShowSystemNamespaces </span><span class="cov0" title="0">{
                actions[3] = "S Ocultar Sistema"
        }</span>

        <span class="cov0" title="0">footer := a.renderActionFooter(actions)
        content.WriteString("\n" + footer)

        return content.String()</span>
}

// renderNamespacesSidebar - Sidebar com namespaces
func (a *App) renderNamespacesSidebar() string <span class="cov0" title="0">{
        var items []string

        // Header
        filterStatus := "🔍 Namespaces"
        if a.model.ShowSystemNamespaces </span><span class="cov0" title="0">{
                filterStatus += " (todos)"
        }</span> else<span class="cov0" title="0"> {
                filterStatus += " (filtrados)"
        }</span>
        
        <span class="cov0" title="0">items = append(items, 
                lipgloss.NewStyle().
                        Foreground(accentColor).
                        Bold(true).
                        Render(filterStatus))
        items = append(items, "")

        // Lista de namespaces
        for i, namespace := range a.model.Namespaces </span><span class="cov0" title="0">{
                var icon string
                hpaText := ""

                // Ícone baseado no número de HPAs
                if namespace.HPACount &gt; 0 </span><span class="cov0" title="0">{
                        icon = "📦"
                        hpaText = badgeSuccessStyle.Render(fmt.Sprintf("%d", namespace.HPACount))
                }</span> else<span class="cov0" title="0"> {
                        icon = "📂"
                        hpaText = badgeWarningStyle.Render("0")
                }</span>

                // Nome truncado
                <span class="cov0" title="0">nsName := truncateString(namespace.Name, 18)
                itemText := fmt.Sprintf("%s %s", icon, nsName)

                var item string
                if i == a.model.SelectedIndex </span><span class="cov0" title="0">{
                        item = selectedItemStyle.Render("▶ " + itemText) + " " + hpaText
                }</span> else<span class="cov0" title="0"> {
                        item = normalItemStyle.Render("  " + itemText) + " " + hpaText
                }</span>

                <span class="cov0" title="0">items = append(items, item)</span>
        }

        <span class="cov0" title="0">if len(a.model.Namespaces) == 0 &amp;&amp; a.model.Loading </span><span class="cov0" title="0">{
                items = append(items, normalItemStyle.Render("  🔄 Carregando..."))
        }</span>

        <span class="cov0" title="0">content := strings.Join(items, "\n")
        return sidebarStyle.Render(content)</span>
}

// renderNamespaceDetails - Detalhes do namespace selecionado
func (a *App) renderNamespaceDetails() string <span class="cov0" title="0">{
        var content strings.Builder

        // Stats do namespace
        total := len(a.model.Namespaces)
        withHPAs := 0
        totalHPAs := 0

        for _, ns := range a.model.Namespaces </span><span class="cov0" title="0">{
                if ns.HPACount &gt; 0 </span><span class="cov0" title="0">{
                        withHPAs++
                }</span>
                <span class="cov0" title="0">totalHPAs += ns.HPACount</span>
        }

        // Cards de estatísticas
        <span class="cov0" title="0">namespaceCard := cardStyle.Width(20).Render(
                statusConnectedStyle.Render("📁 Namespaces") + "\n" +
                fmt.Sprintf("%d Total", total))

        hpaCard := cardStyle.Width(20).Render(
                lipgloss.NewStyle().Foreground(accentColor).Bold(true).Render("🎯 HPAs") + "\n" +
                fmt.Sprintf("%d Total", totalHPAs))

        activeCard := cardStyle.Width(20).Render(
                lipgloss.NewStyle().Foreground(successColor).Bold(true).Render("✅ Ativos") + "\n" +
                fmt.Sprintf("%d com HPAs", withHPAs))

        statsCards := lipgloss.JoinHorizontal(lipgloss.Top, namespaceCard, hpaCard, activeCard)
        content.WriteString(statsCards + "\n")

        // Detalhes do namespace selecionado
        if a.model.SelectedIndex &lt; len(a.model.Namespaces) </span><span class="cov0" title="0">{
                selectedNS := a.model.Namespaces[a.model.SelectedIndex]
                nsDetails := a.renderSelectedNamespaceDetails(selectedNS)
                content.WriteString(nsDetails)
        }</span>

        <span class="cov0" title="0">return panelStyle.Width(maxWidth - sidebarWidth - 6).Render(content.String())</span>
}

// renderSelectedNamespaceDetails - Detalhes do namespace selecionado
func (a *App) renderSelectedNamespaceDetails(namespace models.Namespace) string <span class="cov0" title="0">{
        var content strings.Builder

        content.WriteString(
                lipgloss.NewStyle().
                        Foreground(primaryColor).
                        Bold(true).
                        Render("🎯 Namespace Selecionado") + "\n\n")

        content.WriteString(fmt.Sprintf("📛 Nome: %s\n", namespace.Name))
        content.WriteString(fmt.Sprintf("🏗️  Cluster: %s\n", namespace.Cluster))
        
        // Status dos HPAs
        var hpaStatus string
        var statusStyle lipgloss.Style
        if namespace.HPACount &gt; 0 </span><span class="cov0" title="0">{
                hpaStatus = fmt.Sprintf("%d HPAs configurados", namespace.HPACount)
                statusStyle = lipgloss.NewStyle().Foreground(successColor)
        }</span> else<span class="cov0" title="0"> {
                hpaStatus = "Nenhum HPA encontrado"
                statusStyle = lipgloss.NewStyle().Foreground(warningColor)
        }</span>

        <span class="cov0" title="0">content.WriteString(fmt.Sprintf("🎯 HPAs: %s\n", statusStyle.Render(hpaStatus)))

        // Preview de ações
        if namespace.HPACount &gt; 0 </span><span class="cov0" title="0">{
                content.WriteString("\n" + lipgloss.NewStyle().Foreground(successColor).Render("🚀 Pronto para gerenciar HPAs!"))
        }</span> else<span class="cov0" title="0"> {
                content.WriteString("\n" + lipgloss.NewStyle().Foreground(warningColor).Render("⚠️  Namespace sem HPAs configurados"))
        }</span>

        <span class="cov0" title="0">return cardStyle.Width(maxWidth - sidebarWidth - 10).Render(content.String())</span>
}

// renderModernHeader - Header moderno com breadcrumb
func (a *App) renderModernHeader(breadcrumb, subtitle string) string <span class="cov0" title="0">{
        var content strings.Builder
        
        // Título principal
        title := "🎯 Kubernetes HPA Manager"
        content.WriteString(
                lipgloss.NewStyle().
                        Foreground(textColor).
                        Bold(true).
                        Render(title))
        
        // Breadcrumb
        content.WriteString("  " + 
                lipgloss.NewStyle().
                        Foreground(textMutedColor).
                        Render(breadcrumb))
        
        // Subtitle
        if subtitle != "" </span><span class="cov0" title="0">{
                content.WriteString("\n" + 
                        lipgloss.NewStyle().
                                Foreground(accentColor).
                                Render(subtitle))
        }</span>

        <span class="cov0" title="0">return headerStyle.Width(maxWidth).Render(content.String())</span>
}

// renderActionFooter - Footer moderno com ações
func (a *App) renderActionFooter(actions []string) string <span class="cov0" title="0">{
        var items []string
        
        for _, action := range actions </span><span class="cov0" title="0">{
                items = append(items, 
                        lipgloss.NewStyle().
                                Background(primaryColor).
                                Foreground(textColor).
                                Padding(0, 1).
                                Render(action))
        }</span>
        
        <span class="cov0" title="0">footer := strings.Join(items, "  ")
        return helpTextStyle.Width(maxWidth).Render(footer)</span>
}

// renderProgressBar - Barra de progresso moderna
func (a *App) renderProgressBar(current, total int, width int) string <span class="cov0" title="0">{
        if total == 0 </span><span class="cov0" title="0">{
                return progressBarStyle.Width(width).Render("")
        }</span>
        
        <span class="cov0" title="0">progress := float64(current) / float64(total)
        filled := int(progress * float64(width))
        
        if filled &gt; width </span><span class="cov0" title="0">{
                filled = width
        }</span>
        
        <span class="cov0" title="0">bar := progressFillStyle.Width(filled).Render("") +
                progressBarStyle.Width(width - filled).Render("")
        
        percentage := fmt.Sprintf(" %.0f%%", progress * 100)
        
        return bar + 
                lipgloss.NewStyle().
                        Foreground(textMutedColor).
                        Render(percentage)</span>
}

// renderHPAManagement - Layout moderno para gerenciamento de HPAs
func (a *App) renderHPAManagement() string <span class="cov0" title="0">{
        var content strings.Builder

        // Header com breadcrumb
        selectedCluster := ""
        selectedNamespace := ""
        for _, cluster := range a.model.Clusters </span><span class="cov0" title="0">{
                if cluster.Selected </span><span class="cov0" title="0">{
                        selectedCluster = cluster.Name
                        break</span>
                }
        }
        <span class="cov0" title="0">for _, ns := range a.model.Namespaces </span><span class="cov0" title="0">{
                if ns.Selected </span><span class="cov0" title="0">{
                        selectedNamespace = ns.Name
                        break</span>
                }
        }

        <span class="cov0" title="0">header := a.renderModernHeader("🏠 Dashboard &gt; 📁 Namespaces &gt; 🎯 HPAs", 
                fmt.Sprintf("%s / %s", selectedCluster, selectedNamespace))
        content.WriteString(header + "\n")

        // Layout em duas colunas
        leftColumn := a.renderHPAsSidebar()
        rightColumn := a.renderHPAManagementDetails()

        mainContent := lipgloss.JoinHorizontal(
                lipgloss.Top,
                leftColumn,
                rightColumn,
        )

        content.WriteString(mainContent)

        // Footer com ações
        footer := a.renderActionFooter([]string{
                "↑↓ Navegar",
                "SPACE Selecionar",
                "ENTER Editar",
                "Ctrl+U Aplicar",
                "Ctrl+R Rollout",
                "Ctrl+S Sessões",
                "A Selec. Todos",
                "ESC Voltar",
        })
        content.WriteString("\n" + footer)

        return content.String()</span>
}

// renderHPAsSidebar - Sidebar com lista de HPAs
func (a *App) renderHPAsSidebar() string <span class="cov0" title="0">{
        var items []string

        // Header da sidebar
        selectedCount := 0
        modifiedCount := 0
        for _, hpa := range a.model.HPAs </span><span class="cov0" title="0">{
                if hpa.Selected </span><span class="cov0" title="0">{
                        selectedCount++
                }</span>
                <span class="cov0" title="0">if hpa.Modified </span><span class="cov0" title="0">{
                        modifiedCount++
                }</span>
        }

        <span class="cov0" title="0">headerText := fmt.Sprintf("🎯 HPAs (%d total)", len(a.model.HPAs))
        if selectedCount &gt; 0 </span><span class="cov0" title="0">{
                headerText += fmt.Sprintf(" - %d selecionados", selectedCount)
        }</span>
        
        <span class="cov0" title="0">items = append(items, 
                lipgloss.NewStyle().
                        Foreground(accentColor).
                        Bold(true).
                        Render(headerText))
        items = append(items, "")

        // Lista de HPAs
        for i, hpa := range a.model.HPAs </span><span class="cov0" title="0">{
                var icon, checkbox string
                var itemStyle lipgloss.Style

                // Checkbox
                if hpa.Selected </span><span class="cov0" title="0">{
                        checkbox = "☑"
                }</span> else<span class="cov0" title="0"> {
                        checkbox = "☐"
                }</span>

                // Ícone e status
                <span class="cov0" title="0">if hpa.Modified </span><span class="cov0" title="0">{
                        icon = "✨"
                        itemStyle = lipgloss.NewStyle().Foreground(warningColor).Bold(true)
                }</span> else<span class="cov0" title="0"> {
                        icon = "📊"
                        itemStyle = normalItemStyle
                }</span>

                // Nome truncado e informações
                <span class="cov0" title="0">hpaName := truncateString(hpa.Name, 15)
                minReplicas := getIntValue(hpa.MinReplicas)
                
                itemText := fmt.Sprintf("%s %s %s (%d-%d)", 
                        checkbox, icon, hpaName, minReplicas, hpa.MaxReplicas)

                var item string
                if i == a.model.SelectedIndex </span><span class="cov0" title="0">{
                        item = selectedItemStyle.Render("▶ " + itemText)
                }</span> else<span class="cov0" title="0"> {
                        item = itemStyle.Render("  " + itemText)
                }</span>

                <span class="cov0" title="0">items = append(items, item)</span>
        }

        <span class="cov0" title="0">if len(a.model.HPAs) == 0 &amp;&amp; a.model.Loading </span><span class="cov0" title="0">{
                items = append(items, normalItemStyle.Render("  🔄 Carregando..."))
        }</span>

        // Status summary
        <span class="cov0" title="0">if modifiedCount &gt; 0 </span><span class="cov0" title="0">{
                items = append(items, "")
                items = append(items, 
                        lipgloss.NewStyle().Foreground(warningColor).Render(fmt.Sprintf("⚡ %d HPAs modificados", modifiedCount)))
        }</span>

        <span class="cov0" title="0">content := strings.Join(items, "\n")
        return sidebarStyle.Render(content)</span>
}

// renderHPAManagementDetails - Painel principal com detalhes dos HPAs
func (a *App) renderHPAManagementDetails() string <span class="cov0" title="0">{
        var content strings.Builder

        // Cards de estatísticas
        total := len(a.model.HPAs)
        selected := 0
        modified := 0
        totalCurrentReplicas := int32(0)

        for _, hpa := range a.model.HPAs </span><span class="cov0" title="0">{
                if hpa.Selected </span><span class="cov0" title="0">{
                        selected++
                }</span>
                <span class="cov0" title="0">if hpa.Modified </span><span class="cov0" title="0">{
                        modified++
                }</span>
                <span class="cov0" title="0">totalCurrentReplicas += hpa.CurrentReplicas</span>
        }

        // Cards de stats
        <span class="cov0" title="0">totalCard := cardStyle.Width(18).Render(
                statusConnectedStyle.Render("📊 Total HPAs") + "\n" +
                fmt.Sprintf("%d configurados", total))

        selectedCard := cardStyle.Width(18).Render(
                lipgloss.NewStyle().Foreground(primaryColor).Bold(true).Render("☑ Selecionados") + "\n" +
                fmt.Sprintf("%d marcados", selected))

        modifiedCard := cardStyle.Width(18).Render(
                lipgloss.NewStyle().Foreground(warningColor).Bold(true).Render("✨ Modificados") + "\n" +
                fmt.Sprintf("%d alterados", modified))

        replicasCard := cardStyle.Width(18).Render(
                lipgloss.NewStyle().Foreground(accentColor).Bold(true).Render("🔄 Replicas") + "\n" +
                fmt.Sprintf("%d ativas", totalCurrentReplicas))

        statsCards := lipgloss.JoinHorizontal(lipgloss.Top, totalCard, selectedCard, modifiedCard, replicasCard)
        content.WriteString(statsCards + "\n")

        // Detalhes do HPA selecionado
        if a.model.SelectedIndex &lt; len(a.model.HPAs) </span><span class="cov0" title="0">{
                selectedHPA := a.model.HPAs[a.model.SelectedIndex]
                hpaDetails := a.renderSelectedHPADetails(selectedHPA)
                content.WriteString(hpaDetails + "\n")
        }</span>

        // Actions panel
        <span class="cov0" title="0">actionsPanel := a.renderHPAActionsPanel()
        content.WriteString(actionsPanel)

        return panelStyle.Width(maxWidth - sidebarWidth - 6).Render(content.String())</span>
}

// renderSelectedHPADetails - Detalhes do HPA selecionado
func (a *App) renderSelectedHPADetails(hpa models.HPA) string <span class="cov0" title="0">{
        var content strings.Builder

        // Header
        title := "🎯 HPA Selecionado"
        if hpa.Modified </span><span class="cov0" title="0">{
                title += " ✨"
        }</span>
        
        <span class="cov0" title="0">content.WriteString(
                lipgloss.NewStyle().
                        Foreground(primaryColor).
                        Bold(true).
                        Render(title) + "\n\n")

        // Informações básicas
        content.WriteString(fmt.Sprintf("📛 Nome: %s\n", hpa.Name))
        content.WriteString(fmt.Sprintf("📁 Namespace: %s\n", hpa.Namespace))
        content.WriteString(fmt.Sprintf("🏗️  Cluster: %s\n", hpa.Cluster))

        // Configurações atuais vs originais
        content.WriteString("\n" + 
                lipgloss.NewStyle().
                        Foreground(accentColor).
                        Bold(true).
                        Render("⚙️  Configurações") + "\n")

        // Min Replicas
        minCurrent := getIntValue(hpa.MinReplicas)
        minOriginal := getIntValue(hpa.OriginalValues.MinReplicas)
        minStyle := normalItemStyle
        if minCurrent != minOriginal </span><span class="cov0" title="0">{
                minStyle = lipgloss.NewStyle().Foreground(warningColor)
        }</span>
        <span class="cov0" title="0">content.WriteString(fmt.Sprintf("Min Replicas: %s", 
                minStyle.Render(fmt.Sprintf("%d", minCurrent))))
        if minCurrent != minOriginal </span><span class="cov0" title="0">{
                content.WriteString(fmt.Sprintf(" (era %d)", minOriginal))
        }</span>
        <span class="cov0" title="0">content.WriteString("\n")

        // Max Replicas
        maxCurrent := hpa.MaxReplicas
        maxOriginal := hpa.OriginalValues.MaxReplicas
        maxStyle := normalItemStyle
        if maxCurrent != maxOriginal </span><span class="cov0" title="0">{
                maxStyle = lipgloss.NewStyle().Foreground(warningColor)
        }</span>
        <span class="cov0" title="0">content.WriteString(fmt.Sprintf("Max Replicas: %s", 
                maxStyle.Render(fmt.Sprintf("%d", maxCurrent))))
        if maxCurrent != maxOriginal </span><span class="cov0" title="0">{
                content.WriteString(fmt.Sprintf(" (era %d)", maxOriginal))
        }</span>
        <span class="cov0" title="0">content.WriteString("\n")

        // Current Replicas
        content.WriteString(fmt.Sprintf("Current: %s\n", 
                lipgloss.NewStyle().Foreground(successColor).Render(fmt.Sprintf("%d replicas", hpa.CurrentReplicas))))

        // Targets (CPU/Memory)
        if hpa.TargetCPU != nil </span><span class="cov0" title="0">{
                cpuCurrent := *hpa.TargetCPU
                cpuOriginal := int32(80)
                if hpa.OriginalValues.TargetCPU != nil </span><span class="cov0" title="0">{
                        cpuOriginal = *hpa.OriginalValues.TargetCPU
                }</span>
                <span class="cov0" title="0">cpuStyle := normalItemStyle
                if cpuCurrent != cpuOriginal </span><span class="cov0" title="0">{
                        cpuStyle = lipgloss.NewStyle().Foreground(warningColor)
                }</span>
                <span class="cov0" title="0">content.WriteString(fmt.Sprintf("Target CPU: %s", 
                        cpuStyle.Render(fmt.Sprintf("%d%%", cpuCurrent))))
                if cpuCurrent != cpuOriginal </span><span class="cov0" title="0">{
                        content.WriteString(fmt.Sprintf(" (era %d%%)", cpuOriginal))
                }</span>
                <span class="cov0" title="0">content.WriteString("\n")</span>
        }

        // Status
        <span class="cov0" title="0">if hpa.Selected </span><span class="cov0" title="0">{
                content.WriteString("\n" + selectedItemStyle.Render("✅ Selecionado para edição"))
        }</span>
        <span class="cov0" title="0">if hpa.Modified </span><span class="cov0" title="0">{
                content.WriteString("\n" + lipgloss.NewStyle().Foreground(warningColor).Render("⚡ Modificado - precisa aplicar"))
        }</span>

        <span class="cov0" title="0">return cardStyle.Width(maxWidth - sidebarWidth - 10).Render(content.String())</span>
}

// renderHPAActionsPanel - Painel de ações disponíveis
func (a *App) renderHPAActionsPanel() string <span class="cov0" title="0">{
        var content strings.Builder

        content.WriteString(
                lipgloss.NewStyle().
                        Foreground(accentColor).
                        Bold(true).
                        Render("🚀 Ações Disponíveis") + "\n\n")

        // Lista de ações com status
        actions := []struct {
                key    string
                action string
                desc   string
                enabled bool
        }{
                {"ENTER", "Editar HPA", "Abrir editor para o HPA selecionado", true},
                {"Ctrl+U", "Aplicar Mudanças", "Aplicar HPAs modificados", a.hasModifiedHPAs()},
                {"Ctrl+R", "Rollout", "Reiniciar deployments dos HPAs selecionados", a.hasSelectedHPAs()},
                {"Ctrl+S", "Gerenciar Sessões", "Salvar/carregar configurações", true},
                {"A", "Selecionar Todos", "Marcar todos os HPAs", len(a.model.HPAs) &gt; 0},
        }

        for _, action := range actions </span><span class="cov0" title="0">{
                var style lipgloss.Style
                var icon string
                
                if action.enabled </span><span class="cov0" title="0">{
                        style = normalItemStyle
                        icon = "✅"
                }</span> else<span class="cov0" title="0"> {
                        style = lipgloss.NewStyle().Foreground(mutedColor)
                        icon = "⚪"
                }</span>
                
                <span class="cov0" title="0">actionText := fmt.Sprintf("%s [%s] %s\n    %s", 
                        icon, action.key, action.action, action.desc)
                content.WriteString(style.Render(actionText) + "\n\n")</span>
        }

        <span class="cov0" title="0">return cardStyle.Width(maxWidth - sidebarWidth - 10).Render(content.String())</span>
}

// renderHPAEditing - Layout moderno para edição de HPA
func (a *App) renderHPAEditing() string <span class="cov0" title="0">{
        if a.model.EditingHPA == nil </span><span class="cov0" title="0">{
                return "No HPA being edited"
        }</span>

        <span class="cov0" title="0">hpa := a.model.EditingHPA
        var content strings.Builder

        // Header com breadcrumb
        header := a.renderModernHeader("🏠 Dashboard &gt; 📁 Namespaces &gt; 🎯 HPAs &gt; ✏️ Editor", 
                fmt.Sprintf("Editando: %s", hpa.Name))
        content.WriteString(header + "\n")

        // Layout em duas colunas
        leftColumn := a.renderEditFormSidebar(hpa)
        rightColumn := a.renderEditPreview(hpa)

        mainContent := lipgloss.JoinHorizontal(
                lipgloss.Top,
                leftColumn,
                rightColumn,
        )

        content.WriteString(mainContent)

        // Footer com ações
        footer := a.renderActionFooter([]string{
                "TAB Próximo Campo",
                "↑↓ Ajustar Valor",
                "0-9 Digitar",
                "ENTER Aplicar",
                "ESC Cancelar",
        })
        content.WriteString("\n" + footer)

        return content.String()</span>
}

// renderEditFormSidebar - Formulário de edição na sidebar
func (a *App) renderEditFormSidebar(hpa *models.HPA) string <span class="cov0" title="0">{
        var items []string

        // Header
        items = append(items, 
                lipgloss.NewStyle().
                        Foreground(accentColor).
                        Bold(true).
                        Render("✏️  Formulário de Edição"))
        items = append(items, "")

        // Helper para renderizar campo
        renderField := func(fieldKey, label, unit string, originalValue int32) </span><span class="cov0" title="0">{
                currentValue := a.model.FormFields[fieldKey]
                if currentValue == "" </span><span class="cov0" title="0">{
                        currentValue = fmt.Sprintf("%d", originalValue)
                }</span>

                // Estilo baseado no campo ativo
                <span class="cov0" title="0">var fieldStyle lipgloss.Style
                var cursor string
                if a.model.ActiveField == fieldKey </span><span class="cov0" title="0">{
                        fieldStyle = selectedItemStyle
                        cursor = "▶ "
                }</span> else<span class="cov0" title="0"> {
                        fieldStyle = normalItemStyle
                        cursor = "  "
                }</span>

                // Verificar se foi modificado
                <span class="cov0" title="0">var modifiedIndicator string
                if currentVal, err := strconv.Atoi(currentValue); err == nil &amp;&amp; currentVal != int(originalValue) </span><span class="cov0" title="0">{
                        modifiedIndicator = " " + lipgloss.NewStyle().Foreground(warningColor).Render("✨")
                }</span>

                <span class="cov0" title="0">fieldText := fmt.Sprintf("%s%s", cursor, label)
                valueText := fmt.Sprintf("[%s%s]%s", currentValue, unit, modifiedIndicator)
                
                items = append(items, fieldStyle.Render(fieldText))
                items = append(items, "  " + inputStyle.Render(valueText))
                items = append(items, "")</span>
        }

        // Campos editáveis
        <span class="cov0" title="0">if hpa.OriginalValues != nil </span><span class="cov0" title="0">{
                renderField(models.FieldMinReplicas, "Min Replicas", "", getIntValue(hpa.OriginalValues.MinReplicas))
                renderField(models.FieldMaxReplicas, "Max Replicas", "", hpa.OriginalValues.MaxReplicas)
                renderField(models.FieldTargetCPU, "Target CPU", "%", getIntValue(hpa.OriginalValues.TargetCPU))
                renderField(models.FieldTargetMemory, "Target Memory", "%", getIntValue(hpa.OriginalValues.TargetMemory))
        }</span>

        // Campo de rollout
        <span class="cov0" title="0">var rolloutStyle lipgloss.Style
        var rolloutCursor string
        if a.model.ActiveField == models.FieldRollout </span><span class="cov0" title="0">{
                rolloutStyle = selectedItemStyle
                rolloutCursor = "▶ "
        }</span> else<span class="cov0" title="0"> {
                rolloutStyle = normalItemStyle
                rolloutCursor = "  "
        }</span>
        
        <span class="cov0" title="0">var checkbox string
        if a.model.PerformRollout </span><span class="cov0" title="0">{
                checkbox = "☑"
        }</span> else<span class="cov0" title="0"> {
                checkbox = "☐"
        }</span>
        
        <span class="cov0" title="0">rolloutText := fmt.Sprintf("%sRollout após aplicar", rolloutCursor)
        checkboxText := fmt.Sprintf("%s Reiniciar deployment", checkbox)
        
        items = append(items, rolloutStyle.Render(rolloutText))
        items = append(items, "  " + inputStyle.Render(checkboxText))

        content := strings.Join(items, "\n")
        return sidebarStyle.Render(content)</span>
}

// renderEditPreview - Preview das mudanças
func (a *App) renderEditPreview(hpa *models.HPA) string <span class="cov0" title="0">{
        var content strings.Builder

        // Preview das mudanças
        content.WriteString(
                lipgloss.NewStyle().
                        Foreground(primaryColor).
                        Bold(true).
                        Render("👁️  Preview das Mudanças") + "\n\n")

        // Informações do HPA
        content.WriteString(fmt.Sprintf("📛 HPA: %s\n", hpa.Name))
        content.WriteString(fmt.Sprintf("📁 Namespace: %s\n", hpa.Namespace))
        content.WriteString(fmt.Sprintf("🏗️  Cluster: %s\n\n", hpa.Cluster))

        // Tabela de mudanças
        content.WriteString(
                lipgloss.NewStyle().
                        Foreground(accentColor).
                        Bold(true).
                        Render("📊 Comparação") + "\n\n")

        // Helper para mostrar mudança
        showChange := func(label, fieldKey string, originalValue int32, unit string) </span><span class="cov0" title="0">{
                currentStr := a.model.FormFields[fieldKey]
                if currentStr == "" </span><span class="cov0" title="0">{
                        currentStr = fmt.Sprintf("%d", originalValue)
                }</span>
                
                <span class="cov0" title="0">currentValue, _ := strconv.Atoi(currentStr)
                
                var changeStyle lipgloss.Style
                var changeIcon string
                
                if currentValue != int(originalValue) </span><span class="cov0" title="0">{
                        if currentValue &gt; int(originalValue) </span><span class="cov0" title="0">{
                                changeStyle = lipgloss.NewStyle().Foreground(successColor)
                                changeIcon = "📈"
                        }</span> else<span class="cov0" title="0"> {
                                changeStyle = lipgloss.NewStyle().Foreground(warningColor)
                                changeIcon = "📉"
                        }</span>
                } else<span class="cov0" title="0"> {
                        changeStyle = normalItemStyle
                        changeIcon = "➡️"
                }</span>
                
                <span class="cov0" title="0">changeText := fmt.Sprintf("%s %s: %d%s → %s%s", 
                        changeIcon, label, originalValue, unit, 
                        changeStyle.Render(fmt.Sprintf("%d%s", currentValue, unit)), "")
                
                content.WriteString(changeText + "\n")</span>
        }

        <span class="cov0" title="0">if hpa.OriginalValues != nil </span><span class="cov0" title="0">{
                showChange("Min Replicas", models.FieldMinReplicas, getIntValue(hpa.OriginalValues.MinReplicas), "")
                showChange("Max Replicas", models.FieldMaxReplicas, hpa.OriginalValues.MaxReplicas, "")
                showChange("Target CPU", models.FieldTargetCPU, getIntValue(hpa.OriginalValues.TargetCPU), "%")
                showChange("Target Memory", models.FieldTargetMemory, getIntValue(hpa.OriginalValues.TargetMemory), "%")
        }</span>

        // Impacto estimado
        <span class="cov0" title="0">content.WriteString("\n" + 
                lipgloss.NewStyle().
                        Foreground(accentColor).
                        Bold(true).
                        Render("⚡ Impacto Estimado") + "\n\n")

        minStr := a.model.FormFields[models.FieldMinReplicas]
        maxStr := a.model.FormFields[models.FieldMaxReplicas]
        
        if minStr != "" &amp;&amp; maxStr != "" </span><span class="cov0" title="0">{
                minVal, _ := strconv.Atoi(minStr)
                maxVal, _ := strconv.Atoi(maxStr)
                
                content.WriteString(fmt.Sprintf("🎯 Faixa de escala: %d - %d replicas\n", minVal, maxVal))
                content.WriteString(fmt.Sprintf("📊 Current: %d replicas\n", hpa.CurrentReplicas))
                
                if int32(minVal) &gt; hpa.CurrentReplicas </span><span class="cov0" title="0">{
                        content.WriteString(lipgloss.NewStyle().Foreground(warningColor).Render("⚠️  Irá escalar PARA CIMA imediatamente\n"))
                }</span> else<span class="cov0" title="0"> if int32(maxVal) &lt; hpa.CurrentReplicas </span><span class="cov0" title="0">{
                        content.WriteString(lipgloss.NewStyle().Foreground(warningColor).Render("⚠️  Irá escalar PARA BAIXO imediatamente\n"))
                }</span> else<span class="cov0" title="0"> {
                        content.WriteString(lipgloss.NewStyle().Foreground(successColor).Render("✅ Dentro da faixa atual\n"))
                }</span>
        }

        <span class="cov0" title="0">if a.model.PerformRollout </span><span class="cov0" title="0">{
                content.WriteString("\n" + lipgloss.NewStyle().Foreground(warningColor).Render("🔄 Deployment será reiniciado após aplicar"))
        }</span>

        <span class="cov0" title="0">return panelStyle.Width(maxWidth - sidebarWidth - 6).Render(content.String())</span>
}

// renderSessionManager - Layout moderno para gerenciamento de sessões
func (a *App) renderSessionManager() string <span class="cov0" title="0">{
        var content strings.Builder

        // Header com breadcrumb
        var title string
        if a.model.PreviousState == models.StateClusterDiscovery </span><span class="cov0" title="0">{
                title = "🏠 Dashboard &gt; 💾 Carregar Sessão"
        }</span> else<span class="cov0" title="0"> {
                title = "🏠 Dashboard &gt; 💾 Gerenciar Sessões"
        }</span>
        
        <span class="cov0" title="0">header := a.renderModernHeader(title, "Salvar e Carregar Configurações")
        content.WriteString(header + "\n")

        // Layout em duas colunas
        leftColumn := a.renderSessionsSidebar()
        rightColumn := a.renderSessionDetails()

        mainContent := lipgloss.JoinHorizontal(
                lipgloss.Top,
                leftColumn,
                rightColumn,
        )

        content.WriteString(mainContent)

        // Input de nome da sessão
        if a.model.EnteringSessionName </span><span class="cov0" title="0">{
                sessionInput := a.renderSessionNameInput()
                content.WriteString("\n" + sessionInput)
        }</span>

        // Footer com ações
        <span class="cov0" title="0">var actions []string
        if a.model.EnteringSessionName </span><span class="cov0" title="0">{
                actions = []string{"ENTER Salvar", "ESC Cancelar", "BACKSPACE Apagar"}
        }</span> else<span class="cov0" title="0"> {
                actions = []string{
                        "↑↓ Navegar",
                        "ENTER Carregar",
                        "Ctrl+N Nova",
                        "Ctrl+W Salvar",
                        "Ctrl+D Deletar",
                        "ESC Voltar",
                }
        }</span>

        <span class="cov0" title="0">footer := a.renderActionFooter(actions)
        content.WriteString("\n" + footer)

        return content.String()</span>
}

// renderSessionsSidebar - Lista de sessões na sidebar
func (a *App) renderSessionsSidebar() string <span class="cov0" title="0">{
        var items []string

        // Header
        items = append(items, 
                lipgloss.NewStyle().
                        Foreground(accentColor).
                        Bold(true).
                        Render(fmt.Sprintf("💾 Sessões Salvas (%d)", len(a.model.Sessions))))
        items = append(items, "")

        // Lista de sessões
        for i, session := range a.model.Sessions </span><span class="cov0" title="0">{
                // Calcular idade
                age := "hoje"
                if !session.CreatedAt.IsZero() </span><span class="cov0" title="0">{
                        duration := time.Since(session.CreatedAt)
                        if duration.Hours() &gt; 24 </span><span class="cov0" title="0">{
                                age = fmt.Sprintf("%.0f dias", duration.Hours()/24)
                        }</span> else<span class="cov0" title="0"> if duration.Hours() &gt; 1 </span><span class="cov0" title="0">{
                                age = fmt.Sprintf("%.0fh", duration.Hours())
                        }</span> else<span class="cov0" title="0"> {
                                age = fmt.Sprintf("%.0fm", duration.Minutes())
                        }</span>
                }

                // Informações da sessão
                <span class="cov0" title="0">hpaCount := len(session.Changes)
                clusterCount := 1
                if session.Metadata != nil </span><span class="cov0" title="0">{
                        clusterCount = len(session.Metadata.ClustersAffected)
                }</span>

                // Nome truncado
                <span class="cov0" title="0">sessionName := truncateString(session.Name, 20)
                
                var icon string
                if session.Name == a.model.CurrentSession.Name </span><span class="cov0" title="0">{
                        icon = "⭐"
                }</span> else<span class="cov0" title="0"> {
                        icon = "💾"
                }</span>

                <span class="cov0" title="0">itemText := fmt.Sprintf("%s %s", icon, sessionName)
                detailText := fmt.Sprintf("   %d HPAs | %d clusters | %s", hpaCount, clusterCount, age)

                var item string
                if i == a.model.SelectedIndex </span><span class="cov0" title="0">{
                        item = selectedItemStyle.Render("▶ " + itemText)
                        items = append(items, item)
                        items = append(items, selectedItemStyle.Render(detailText))
                }</span> else<span class="cov0" title="0"> {
                        item = normalItemStyle.Render("  " + itemText)
                        items = append(items, item)
                        items = append(items, normalItemStyle.Render(detailText))
                }</span>
                <span class="cov0" title="0">items = append(items, "")</span>
        }

        <span class="cov0" title="0">if len(a.model.Sessions) == 0 </span><span class="cov0" title="0">{
                items = append(items, normalItemStyle.Render("  Nenhuma sessão salva"))
        }</span>

        <span class="cov0" title="0">content := strings.Join(items, "\n")
        return sidebarStyle.Render(content)</span>
}

// renderSessionDetails - Detalhes da sessão selecionada
func (a *App) renderSessionDetails() string <span class="cov0" title="0">{
        var content strings.Builder

        // Sessão atual
        if a.model.CurrentSession != nil </span><span class="cov0" title="0">{
                currentSessionCard := cardStyle.Width(maxWidth - sidebarWidth - 10).Render(
                        lipgloss.NewStyle().Foreground(successColor).Bold(true).Render("⭐ Sessão Atual") + "\n" +
                        fmt.Sprintf("📛 Nome: %s\n", a.model.CurrentSession.Name) +
                        fmt.Sprintf("🕒 Criada: %s\n", a.model.CurrentSession.CreatedAt.Format("02/01/2006 15:04")) +
                        fmt.Sprintf("👤 Por: %s\n", a.model.CurrentSession.CreatedBy) +
                        fmt.Sprintf("📊 %d mudanças salvas", len(a.model.CurrentSession.Changes)))
                
                content.WriteString(currentSessionCard + "\n")
        }</span>

        // Mudanças pendentes
        <span class="cov0" title="0">pendingChanges := a.renderPendingChangesModern()
        content.WriteString(pendingChanges + "\n")

        // Detalhes da sessão selecionada
        if len(a.model.Sessions) &gt; 0 &amp;&amp; a.model.SelectedIndex &lt; len(a.model.Sessions) </span><span class="cov0" title="0">{
                selectedSession := a.model.Sessions[a.model.SelectedIndex]
                sessionDetails := a.renderSelectedSessionDetails(selectedSession)
                content.WriteString(sessionDetails)
        }</span>

        <span class="cov0" title="0">return panelStyle.Width(maxWidth - sidebarWidth - 6).Render(content.String())</span>
}

// renderPendingChangesModern - Mudanças pendentes com estilo moderno
func (a *App) renderPendingChangesModern() string <span class="cov0" title="0">{
        var content strings.Builder

        content.WriteString(
                lipgloss.NewStyle().
                        Foreground(warningColor).
                        Bold(true).
                        Render("⚡ Mudanças Pendentes") + "\n\n")

        pendingCount := 0
        for _, hpa := range a.model.HPAs </span><span class="cov0" title="0">{
                if hpa.Modified </span><span class="cov0" title="0">{
                        pendingCount++
                        
                        var changes []string
                        minOrig := getIntValue(hpa.OriginalValues.MinReplicas)
                        minCurr := getIntValue(hpa.MinReplicas)
                        if minOrig != minCurr </span><span class="cov0" title="0">{
                                changes = append(changes, fmt.Sprintf("Min: %d→%d", minOrig, minCurr))
                        }</span>

                        <span class="cov0" title="0">maxOrig := hpa.OriginalValues.MaxReplicas
                        maxCurr := hpa.MaxReplicas
                        if maxOrig != maxCurr </span><span class="cov0" title="0">{
                                changes = append(changes, fmt.Sprintf("Max: %d→%d", maxOrig, maxCurr))
                        }</span>

                        <span class="cov0" title="0">if len(changes) &gt; 0 </span><span class="cov0" title="0">{
                                changeText := strings.Join(changes, ", ")
                                item := fmt.Sprintf("✨ %s (%s)\n    %s", 
                                        hpa.Name, hpa.Namespace, changeText)
                                content.WriteString(normalItemStyle.Render(item) + "\n")
                        }</span>
                }
        }

        <span class="cov0" title="0">if pendingCount == 0 </span><span class="cov0" title="0">{
                content.WriteString(normalItemStyle.Render("Nenhuma mudança pendente"))
        }</span> else<span class="cov0" title="0"> {
                content.WriteString(fmt.Sprintf("\n%s", 
                        lipgloss.NewStyle().Foreground(warningColor).Render(fmt.Sprintf("Total: %d HPAs modificados", pendingCount))))
        }</span>

        <span class="cov0" title="0">return cardStyle.Width(maxWidth - sidebarWidth - 10).Render(content.String())</span>
}

// renderSelectedSessionDetails - Detalhes da sessão selecionada
func (a *App) renderSelectedSessionDetails(session models.Session) string <span class="cov0" title="0">{
        var content strings.Builder

        content.WriteString(
                lipgloss.NewStyle().
                        Foreground(primaryColor).
                        Bold(true).
                        Render("🔍 Detalhes da Sessão") + "\n\n")

        // Informações básicas
        content.WriteString(fmt.Sprintf("📛 Nome: %s\n", session.Name))
        content.WriteString(fmt.Sprintf("🕒 Criada: %s\n", session.CreatedAt.Format("02/01/2006 15:04:05")))
        content.WriteString(fmt.Sprintf("👤 Criada por: %s\n", session.CreatedBy))
        
        if session.Description != "" </span><span class="cov0" title="0">{
                content.WriteString(fmt.Sprintf("📝 Descrição: %s\n", session.Description))
        }</span>

        // Estatísticas
        <span class="cov0" title="0">content.WriteString("\n" + 
                lipgloss.NewStyle().
                        Foreground(accentColor).
                        Bold(true).
                        Render("📊 Estatísticas") + "\n")

        content.WriteString(fmt.Sprintf("📈 Total de mudanças: %d\n", len(session.Changes)))
        
        if session.Metadata != nil </span><span class="cov0" title="0">{
                content.WriteString(fmt.Sprintf("🏗️  Clusters afetados: %d\n", len(session.Metadata.ClustersAffected)))
                content.WriteString(fmt.Sprintf("📁 Namespaces: %d\n", session.Metadata.NamespacesCount))
                content.WriteString(fmt.Sprintf("🎯 HPAs: %d\n", session.Metadata.HPACount))
        }</span>

        // Preview das mudanças
        <span class="cov0" title="0">if len(session.Changes) &gt; 0 </span><span class="cov0" title="0">{
                content.WriteString("\n" + 
                        lipgloss.NewStyle().
                                Foreground(accentColor).
                                Bold(true).
                                Render("👁️  Preview das Mudanças") + "\n")

                // Mostrar até 3 mudanças
                maxPreview := 3
                if len(session.Changes) &lt; maxPreview </span><span class="cov0" title="0">{
                        maxPreview = len(session.Changes)
                }</span>

                <span class="cov0" title="0">for i := 0; i &lt; maxPreview; i++ </span><span class="cov0" title="0">{
                        change := session.Changes[i]
                        
                        var changeDesc []string
                        if change.OriginalValues != nil &amp;&amp; change.NewValues != nil </span><span class="cov0" title="0">{
                                if getIntValue(change.OriginalValues.MinReplicas) != getIntValue(change.NewValues.MinReplicas) </span><span class="cov0" title="0">{
                                        changeDesc = append(changeDesc, 
                                                fmt.Sprintf("Min: %d→%d", 
                                                        getIntValue(change.OriginalValues.MinReplicas),
                                                        getIntValue(change.NewValues.MinReplicas)))
                                }</span>
                                <span class="cov0" title="0">if change.OriginalValues.MaxReplicas != change.NewValues.MaxReplicas </span><span class="cov0" title="0">{
                                        changeDesc = append(changeDesc, 
                                                fmt.Sprintf("Max: %d→%d", 
                                                        change.OriginalValues.MaxReplicas,
                                                        change.NewValues.MaxReplicas))
                                }</span>
                        }

                        <span class="cov0" title="0">if len(changeDesc) &gt; 0 </span><span class="cov0" title="0">{
                                changeText := strings.Join(changeDesc, ", ")
                                item := fmt.Sprintf("  ✨ %s/%s: %s", 
                                        change.Namespace, change.HPAName, changeText)
                                content.WriteString(normalItemStyle.Render(item) + "\n")
                        }</span>
                }

                <span class="cov0" title="0">if len(session.Changes) &gt; maxPreview </span><span class="cov0" title="0">{
                        content.WriteString(normalItemStyle.Render(
                                fmt.Sprintf("  ... e mais %d mudanças", len(session.Changes) - maxPreview)) + "\n")
                }</span>
        }

        <span class="cov0" title="0">return cardStyle.Width(maxWidth - sidebarWidth - 10).Render(content.String())</span>
}

// renderSessionNameInput - Input para nome da sessão
func (a *App) renderSessionNameInput() string <span class="cov0" title="0">{
        sessionName := a.model.SessionName
        if sessionName == "" </span><span class="cov0" title="0">{
                sessionName = ""
        }</span>

        <span class="cov0" title="0">placeholder := "Digite o nome da sessão..."
        if len(sessionName) == 0 </span><span class="cov0" title="0">{
                sessionName = placeholder
        }</span>

        <span class="cov0" title="0">inputText := fmt.Sprintf("💾 Nome da Sessão: %s", 
                inputFocusedStyle.Width(40).Render(sessionName))

        return cardStyle.Width(maxWidth - 4).Render(inputText)</span>
}

// renderOperationProgress - Layout moderno para progresso de operações
func (a *App) renderOperationProgress() string <span class="cov0" title="0">{
        var content strings.Builder

        // Header
        header := a.renderModernHeader("🏠 Dashboard &gt; 🚀 Aplicando Mudanças", 
                "Executando operações nos clusters")
        content.WriteString(header + "\n")

        // Progress geral
        completed := 0
        failed := 0
        var items []string

        for _, op := range a.model.Operations </span><span class="cov0" title="0">{
                var statusIcon string
                var style lipgloss.Color
                
                switch op.Status </span>{
                case models.OpCompleted:<span class="cov0" title="0">
                        statusIcon = "✅"
                        style = successColor
                        completed++</span>
                case models.OpFailed:<span class="cov0" title="0">
                        statusIcon = "❌"
                        style = errorColor
                        failed++</span>
                case models.OpInProgress:<span class="cov0" title="0">
                        statusIcon = "⏳"
                        style = warningColor</span>
                case models.OpPending:<span class="cov0" title="0">
                        statusIcon = "📋"
                        style = textColor</span>
                case models.OpCancelled:<span class="cov0" title="0">
                        statusIcon = "🚫"
                        style = mutedColor</span>
                }

                // Extrair nome limpo do target
                <span class="cov0" title="0">targetParts := strings.Split(op.Target, "/")
                targetName := op.Target
                if len(targetParts) &gt;= 3 </span><span class="cov0" title="0">{
                        targetName = targetParts[2] // Pegar apenas o nome do HPA
                }</span>

                <span class="cov0" title="0">message := op.Message
                if op.Error != "" </span><span class="cov0" title="0">{
                        message = op.Error
                }</span>

                <span class="cov0" title="0">item := fmt.Sprintf("%s %s\n    %s", 
                        statusIcon, 
                        lipgloss.NewStyle().Foreground(style).Render(targetName), 
                        truncateString(message, 35))
                
                items = append(items, normalItemStyle.Render(item))
                items = append(items, "")</span>
        }

        <span class="cov0" title="0">if len(a.model.Operations) == 0 </span><span class="cov0" title="0">{
                items = append(items, normalItemStyle.Render("Nenhuma operação executada"))
        }</span>

        <span class="cov0" title="0">itemsContent := strings.Join(items, "\n")
        content.WriteString(itemsContent)
        return sidebarStyle.Render(content.String())</span>
}

// renderOperationSummary - Resumo das operações
func (a *App) renderOperationSummary() string <span class="cov0" title="0">{
        var content strings.Builder

        // Calcular estatísticas
        total := len(a.model.Operations)
        completed := 0
        failed := 0
        inProgress := 0
        pending := 0

        for _, op := range a.model.Operations </span><span class="cov0" title="0">{
                switch op.Status </span>{
                case models.OpCompleted:<span class="cov0" title="0">
                        completed++</span>
                case models.OpFailed:<span class="cov0" title="0">
                        failed++</span>
                case models.OpInProgress:<span class="cov0" title="0">
                        inProgress++</span>
                case models.OpPending:<span class="cov0" title="0">
                        pending++</span>
                }
        }

        // Cards de estatísticas
        <span class="cov0" title="0">completedCard := cardStyle.Width(18).Render(
                lipgloss.NewStyle().Foreground(successColor).Render("✅ Concluídas") + "\n" +
                fmt.Sprintf("%d/%d", completed, total))

        failedCard := cardStyle.Width(18).Render(
                lipgloss.NewStyle().Foreground(errorColor).Render("❌ Falharam") + "\n" +
                fmt.Sprintf("%d/%d", failed, total))

        pendingCard := cardStyle.Width(18).Render(
                lipgloss.NewStyle().Foreground(warningColor).Render("⏳ Pendentes") + "\n" +
                fmt.Sprintf("%d/%d", inProgress + pending, total))

        statsCards := lipgloss.JoinHorizontal(lipgloss.Top, completedCard, failedCard, pendingCard)
        content.WriteString(statsCards + "\n")

        // Status geral
        content.WriteString(
                lipgloss.NewStyle().
                        Foreground(primaryColor).
                        Bold(true).
                        Render("📊 Status Geral") + "\n\n")

        var overallStatus string
        var statusStyle lipgloss.Style

        if failed &gt; 0 </span><span class="cov0" title="0">{
                overallStatus = fmt.Sprintf("❌ %d operações falharam", failed)
                statusStyle = lipgloss.NewStyle().Foreground(errorColor)
        }</span> else<span class="cov0" title="0"> if inProgress &gt; 0 || pending &gt; 0 </span><span class="cov0" title="0">{
                overallStatus = "⏳ Operações em andamento..."
                statusStyle = lipgloss.NewStyle().Foreground(warningColor)
        }</span> else<span class="cov0" title="0"> if completed &gt; 0 </span><span class="cov0" title="0">{
                overallStatus = "✅ Todas as operações concluídas!"
                statusStyle = lipgloss.NewStyle().Foreground(successColor)
        }</span> else<span class="cov0" title="0"> {
                overallStatus = "📋 Nenhuma operação executada"
                statusStyle = normalItemStyle
        }</span>

        <span class="cov0" title="0">content.WriteString(statusStyle.Render(overallStatus) + "\n\n")

        // Tempo estimado
        if inProgress &gt; 0 || pending &gt; 0 </span><span class="cov0" title="0">{
                estimatedTime := (inProgress + pending) * 5 // 5 segundos por operação estimado
                content.WriteString(fmt.Sprintf("⏱️  Tempo estimado: %d segundos\n", estimatedTime))
        }</span>

        // Próximos passos
        <span class="cov0" title="0">if completed &gt; 0 &amp;&amp; failed == 0 &amp;&amp; inProgress == 0 &amp;&amp; pending == 0 </span><span class="cov0" title="0">{
                content.WriteString("\n" + 
                        lipgloss.NewStyle().
                                Foreground(accentColor).
                                Bold(true).
                                Render("🎉 Próximos Passos") + "\n\n")
                
                content.WriteString(normalItemStyle.Render("• Verificar se os HPAs foram aplicados corretamente\n"))
                content.WriteString(normalItemStyle.Render("• Monitorar o comportamento do auto-scaling\n"))
                content.WriteString(normalItemStyle.Render("• Salvar a sessão se necessário\n"))
        }</span>

        <span class="cov0" title="0">return panelStyle.Width(maxWidth - sidebarWidth - 6).Render(content.String())</span>
}

// Funções auxiliares para verificar estados
func (a *App) hasModifiedHPAs() bool <span class="cov0" title="0">{
        for _, hpa := range a.model.HPAs </span><span class="cov0" title="0">{
                if hpa.Modified </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func (a *App) hasSelectedHPAs() bool <span class="cov0" title="0">{
        for _, hpa := range a.model.HPAs </span><span class="cov0" title="0">{
                if hpa.Selected </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// Funções utilitárias mantidas
func getIntValue(val *int32) int32 <span class="cov0" title="0">{
        if val == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return *val</span>
}

func truncateString(s string, maxLen int) string <span class="cov0" title="0">{
        if len(s) &lt;= maxLen </span><span class="cov0" title="0">{
                return s
        }</span>
        <span class="cov0" title="0">return s[:maxLen-3] + "..."</span>
}</pre>
		
		<pre class="file" id="file11" style="display: none">package main

import (
        "fmt"
        "os"

        "k8s-hpa-manager/cmd"
)

func main() <span class="cov0" title="0">{
        if err := cmd.Execute(); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error: %v\n", err)
                os.Exit(1)
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
