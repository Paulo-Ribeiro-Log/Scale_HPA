package tui

import (
	"fmt"
	"strconv"
	"strings"

	"k8s-hpa-manager/internal/models"

	"github.com/charmbracelet/lipgloss"
)

// Definir estilos lipgloss
var (
	titleStyle = lipgloss.NewStyle().
		Bold(true).
		Foreground(lipgloss.Color("#FAFAFA")).
		Background(lipgloss.Color("#7D56F4")).
		Padding(0, 1)

	selectedStyle = lipgloss.NewStyle().
		Bold(true).
		Foreground(lipgloss.Color("#EE6FF8")).
		Background(lipgloss.Color("#2A2A2A")).
		Padding(0, 1)

	normalStyle = lipgloss.NewStyle().
		Foreground(lipgloss.Color("#DDDDDD"))

	boxStyle = lipgloss.NewStyle().
		Border(lipgloss.RoundedBorder()).
		BorderForeground(lipgloss.Color("#874BFD")).
		Padding(1, 2)

	helpStyle = lipgloss.NewStyle().
		Foreground(lipgloss.Color("#626262"))

	warningStyle = lipgloss.NewStyle().
		Bold(true).
		Foreground(lipgloss.Color("#FF5F56"))

	headerStyle = lipgloss.NewStyle().
		Bold(true).
		Foreground(lipgloss.Color("#FFFFFF")).
		Background(lipgloss.Color("#5C7CFA")).
		Padding(0, 1)

	successStyle = lipgloss.NewStyle().
		Bold(true).
		Foreground(lipgloss.Color("#00FF00"))

	errorStyle = lipgloss.NewStyle().
		Bold(true).
		Foreground(lipgloss.Color("#FF0000"))
)

// renderClusterDiscovery renderiza a tela de descoberta de clusters
func (a *App) renderClusterDiscovery() string {
	var content strings.Builder

	// T√≠tulo
	title := titleStyle.Render("üîç Kubernetes HPA Manager")
	content.WriteString(title + "\n\n")

	// Status de descoberta
	if a.model.Loading {
		content.WriteString("üîç Descobrindo clusters akspriv-*...\n\n")
	} else {
		content.WriteString(fmt.Sprintf("üìä %d clusters encontrados\n\n", len(a.model.Clusters)))
	}

	// Lista de clusters
	if len(a.model.Clusters) > 0 {
		clusterBox := a.renderClusterList()
		content.WriteString(clusterBox)
	}

	// Contador de selecionados
	selectedCount := 0
	for _, cluster := range a.model.Clusters {
		if cluster.Selected {
			selectedCount++
		}
	}

	if selectedCount > 0 {
		countText := fmt.Sprintf("üìä %d/%d clusters selecionados", selectedCount, len(a.model.Clusters))
		content.WriteString("\n" + countText)
	}

	// Mostrar sess√µes carregadas
	if len(a.model.Sessions) > 0 {
		sessionsText := fmt.Sprintf("üíæ %d sess√µes salvas carregadas", len(a.model.Sessions))
		content.WriteString("\n" + successStyle.Render(sessionsText))
	}

	// Instru√ß√µes
	help := a.renderClusterDiscoveryHelp()
	content.WriteString("\n\n" + help)

	return content.String()
}

// renderClusterList renderiza a lista de clusters
func (a *App) renderClusterList() string {
	var items []string

	for i, cluster := range a.model.Clusters {
		var item string

		// Checkbox
		checkbox := "‚òê"
		if cluster.Selected {
			checkbox = "‚òë"
		}

		// Status
		status := cluster.Status.String()

		// Construir item
		itemText := fmt.Sprintf("%s %s (%s)", checkbox, cluster.Name, status)

		// Aplicar estilo baseado na sele√ß√£o
		if i == a.model.SelectedIndex {
			item = selectedStyle.Render(itemText)
		} else {
			item = normalStyle.Render(itemText)
		}

		items = append(items, item)
	}

	boxContent := strings.Join(items, "\n")
	return boxStyle.Render("Clusters Encontrados\n\n" + boxContent)
}

// renderClusterDiscoveryHelp renderiza a ajuda para descoberta de clusters
func (a *App) renderClusterDiscoveryHelp() string {
	help := "üí° ‚Üë‚Üì navegar  SPACE/ENTER selecionar cluster  [Ctrl+S] Sess√µes Salvas  [R] Refresh"
	return helpStyle.Render(help)
}

// renderNamespaceSelection renderiza a tela de sele√ß√£o de namespaces
func (a *App) renderNamespaceSelection() string {
	var content strings.Builder

	title := titleStyle.Render("üìÇ Sele√ß√£o de Namespaces")
	content.WriteString(title + "\n\n")

	// Agrupar namespaces por cluster
	clusterNamespaces := make(map[string][]models.Namespace)
	for _, ns := range a.model.Namespaces {
		clusterNamespaces[ns.Cluster] = append(clusterNamespaces[ns.Cluster], ns)
	}

	// Renderizar por cluster
	for _, cluster := range a.model.Clusters {
		if !cluster.Selected {
			continue
		}

		content.WriteString(a.renderClusterNamespaces(cluster.Name, clusterNamespaces[cluster.Name]))
		content.WriteString("\n")
	}

	// Contador de selecionados
	selectedCount := 0
	clusterCount := 0
	for _, ns := range a.model.Namespaces {
		if ns.Selected {
			selectedCount++
		}
	}
	for _, cluster := range a.model.Clusters {
		if cluster.Selected {
			clusterCount++
		}
	}

	// Mostrar cluster selecionado
	selectedCluster := ""
	for _, cluster := range a.model.Clusters {
		if cluster.Selected {
			selectedCluster = cluster.Name
			break
		}
	}
	countText := fmt.Sprintf("üìä Cluster: %s (%d namespaces)", selectedCluster, len(a.model.Namespaces))
	content.WriteString("\n" + countText)

	// Instru√ß√µes
	systemStatus := "ocultados"
	if a.model.ShowSystemNamespaces {
		systemStatus = "vis√≠veis"
	}
	help := fmt.Sprintf("üí° ‚Üë‚Üì navegar, SPACE/ENTER selecionar, f filtrar HPAs, s toggle system (%s)", systemStatus)
	content.WriteString("\n\n" + helpStyle.Render(help))

	return content.String()
}

// renderClusterNamespaces renderiza namespaces de um cluster espec√≠fico
func (a *App) renderClusterNamespaces(clusterName string, namespaces []models.Namespace) string {
	var items []string

	// Header do cluster
	status := "‚úÖ Conclu√≠do"
	if a.model.Loading {
		status = "üîÑ Carregando..."
	}

	header := fmt.Sprintf("üìÇ %s                          %s", clusterName, status)

	// Lista de namespaces
	if len(namespaces) > 0 {
		globalIndex := 0
		// Encontrar o √≠ndice global do primeiro namespace deste cluster
		for i, ns := range a.model.Namespaces {
			if ns.Cluster == clusterName {
				globalIndex = i
				break
			}
		}

		for localIndex, ns := range namespaces {
			currentGlobalIndex := globalIndex + localIndex
			
			checkbox := "‚òê"
			if ns.Selected {
				checkbox = "‚òë"
			}

			hpaText := fmt.Sprintf("(%d HPAs)", ns.HPACount)
			if ns.HPACount == 0 {
				hpaText = warningStyle.Render("(0 HPAs)")
			}

			item := fmt.Sprintf("%s %s %s", checkbox, ns.Name, hpaText)
			
			// Destacar item atualmente selecionado
			if currentGlobalIndex == a.model.SelectedIndex {
				item = selectedStyle.Render("‚ñ∂ " + item)
			} else {
				item = normalStyle.Render("  " + item)
			}
			
			items = append(items, item)
		}
	} else {
		items = append(items, normalStyle.Render("  Carregando..."))
	}

	boxContent := header + "\n" + strings.Join(items, "\n")
	return boxStyle.Render(boxContent)
}

// renderHPAManagement renderiza a tela de gerenciamento de HPAs
func (a *App) renderHPAManagement() string {
	var content strings.Builder

	title := titleStyle.Render("üéØ Gerenciamento de HPAs")
	content.WriteString(title + "\n\n")

	// Agrupar HPAs por cluster/namespace
	hpaGroups := make(map[string][]models.HPA)
	for _, hpa := range a.model.HPAs {
		key := fmt.Sprintf("%s/%s", hpa.Cluster, hpa.Namespace)
		hpaGroups[key] = append(hpaGroups[key], hpa)
	}

	// Renderizar por grupo com √≠ndice global
	globalIndex := 0
	for key, hpas := range hpaGroups {
		content.WriteString(a.renderHPAGroupWithIndex(key, hpas, globalIndex))
		content.WriteString("\n")
		globalIndex += len(hpas)
	}

	// A√ß√µes dispon√≠veis
	content.WriteString(a.renderHPAActions())

	// Contador de selecionados
	selectedCount := 0
	modifiedCount := 0
	for _, hpa := range a.model.HPAs {
		if hpa.Selected {
			selectedCount++
		}
		if hpa.Modified {
			modifiedCount++
		}
	}

	status := fmt.Sprintf("üí° %d HPAs selecionados", selectedCount)
	if modifiedCount > 0 {
		status += fmt.Sprintf(" | %d modificados", modifiedCount)
	}
	status += " | ENTER editar, R rollout, S salvar"

	content.WriteString("\n" + helpStyle.Render(status))

	return content.String()
}

// renderHPAGroupWithIndex renderiza um grupo de HPAs com √≠ndice global correto
func (a *App) renderHPAGroupWithIndex(groupKey string, hpas []models.HPA, startIndex int) string {
	var items []string

	header := fmt.Sprintf("üéØ %s", groupKey)

	for i, hpa := range hpas {
		globalIndex := startIndex + i
		
		checkbox := "‚òê"
		if hpa.Selected {
			checkbox = "‚òë"
		}

		// Indicador de modifica√ß√£o
		modified := ""
		if hpa.Modified {
			modified = " ‚ú®"
		}

		values := fmt.Sprintf("Min: %d  Max: %d  Current: %d",
			getIntValue(hpa.MinReplicas), hpa.MaxReplicas, hpa.CurrentReplicas)

		item := fmt.Sprintf("%s %s %s%s", checkbox, hpa.Name, values, modified)

		// Usar o √≠ndice global para comparar com SelectedIndex
		if globalIndex == a.model.SelectedIndex {
			items = append(items, selectedStyle.Render("‚ñ∂ "+item))
		} else {
			items = append(items, normalStyle.Render("  "+item))
		}
	}

	boxContent := header + "\n" + strings.Join(items, "\n")
	return boxStyle.Render(boxContent)
}

// renderHPAGroup renderiza um grupo de HPAs (fun√ß√£o legada)
func (a *App) renderHPAGroup(groupKey string, hpas []models.HPA) string {
	var items []string

	header := fmt.Sprintf("üéØ %s", groupKey)

	for i, hpa := range hpas {
		checkbox := "‚òê"
		if hpa.Selected {
			checkbox = "‚òë"
		}

		// Indicador de modifica√ß√£o
		modified := ""
		if hpa.Modified {
			modified = " ‚ú®"
		}

		values := fmt.Sprintf("Min: %d  Max: %d  Current: %d",
			getIntValue(hpa.MinReplicas), hpa.MaxReplicas, hpa.CurrentReplicas)

		item := fmt.Sprintf("%s %s %s%s", checkbox, hpa.Name, values, modified)

		if i == a.model.SelectedIndex {
			items = append(items, selectedStyle.Render("  "+item))
		} else {
			items = append(items, normalStyle.Render("  "+item))
		}
	}

	boxContent := header + "\n" + strings.Join(items, "\n")
	return boxStyle.Render(boxContent)
}

// renderHPAActions renderiza as a√ß√µes dispon√≠veis para HPAs
func (a *App) renderHPAActions() string {
	actions := []string{
		"[Ctrl+E] Editar Selecionados",
		"[Ctrl+U] Aplicar Mudan√ßas",
		"[Ctrl+R] Rollout",
		"[Ctrl+S] Salvar Sess√£o",
	}

	content := strings.Join(actions, "  ")
	return boxStyle.Render("A√ß√µes\n\n" + content)
}

// renderHPAEditing renderiza o modal de edi√ß√£o de HPA
func (a *App) renderHPAEditing() string {
	if a.model.EditingHPA == nil {
		return "No HPA being edited"
	}

	hpa := a.model.EditingHPA
	var content strings.Builder

	title := fmt.Sprintf("‚úèÔ∏è  Editando HPA: %s/%s", hpa.Namespace, hpa.Name)
	content.WriteString(titleStyle.Render(title) + "\n\n")

	// Informa√ß√µes do cluster
	info := fmt.Sprintf("üìç Cluster: %s", hpa.Cluster)
	content.WriteString(successStyle.Render(info) + "\n\n")

	// Formul√°rio de edi√ß√£o
	content.WriteString(a.renderHPAEditForm(hpa))

	// Instru√ß√µes
	help := "[TAB] Pr√≥ximo Campo  [ENTER] Aplicar  [ESC] Cancelar"
	content.WriteString("\n\n" + helpStyle.Render(help))

	// Aviso de mudan√ßas
	if hpa.Modified {
		warning := "‚ö†Ô∏è  Mudan√ßas detectadas - ser√£o salvas na sess√£o"
		content.WriteString("\n" + warningStyle.Render(warning))
	}

	return content.String()
}

// renderHPAEditForm renderiza o formul√°rio de edi√ß√£o
func (a *App) renderHPAEditForm(hpa *models.HPA) string {
	var content strings.Builder

	// Configura√ß√µes edit√°veis
	content.WriteString(headerStyle.Render("Configura√ß√µes (TAB para navegar)") + "\n\n")

	// Helper para renderizar campo edit√°vel
	renderField := func(fieldKey, label, unit string, originalValue int) {
		currentValue := a.model.FormFields[fieldKey]
		if currentValue == "" {
			currentValue = fmt.Sprintf("%d", originalValue)
		}

		// Estilo baseado se √© o campo ativo
		var fieldStyle lipgloss.Style
		var cursor string
		if a.model.ActiveField == fieldKey {
			fieldStyle = selectedStyle
			cursor = "‚ñ∂ "
		} else {
			fieldStyle = normalStyle
			cursor = "  "
		}

		// Verificar se foi modificado
		var modifiedIndicator string
		if currentVal, err := strconv.Atoi(currentValue); err == nil && currentVal != originalValue {
			modifiedIndicator = " " + successStyle.Render("‚ú®")
		}

		fieldText := fmt.Sprintf("%s%-15s [%-8s]%s%s  ‚Üê Original: %d", 
			cursor, label+":", currentValue+unit, modifiedIndicator, "", originalValue)
		
		content.WriteString(fieldStyle.Render(fieldText) + "\n")
	}

	// Renderizar campos edit√°veis
	renderField(models.FieldMinReplicas, "Min Replicas", "", int(getIntValue(hpa.OriginalValues.MinReplicas)))
	renderField(models.FieldMaxReplicas, "Max Replicas", "", int(hpa.OriginalValues.MaxReplicas))
	renderField(models.FieldTargetCPU, "Target CPU", "%", int(getIntValue(hpa.OriginalValues.TargetCPU)))
	renderField(models.FieldTargetMemory, "Target Memory", "%", int(getIntValue(hpa.OriginalValues.TargetMemory)))
	
	// Renderizar campo de rollout (checkbox)
	var rolloutStyle lipgloss.Style
	var rolloutCursor string
	if a.model.ActiveField == models.FieldRollout {
		rolloutStyle = selectedStyle
		rolloutCursor = "‚ñ∂ "
	} else {
		rolloutStyle = normalStyle
		rolloutCursor = "  "
	}
	
	var checkbox string
	if a.model.PerformRollout {
		checkbox = "[‚úì]"
	} else {
		checkbox = "[ ]"
	}
	
	rolloutText := fmt.Sprintf("%sRollout ap√≥s aplicar: %s (SPACE para alternar)", rolloutCursor, checkbox)
	content.WriteString(rolloutStyle.Render(rolloutText) + "\n")

	content.WriteString("\n")
	
	// Current replicas (read-only)
	content.WriteString(fmt.Sprintf("Current:        %d replicas (read-only)\n", hpa.CurrentReplicas))

	return boxStyle.Render(content.String())
}

// renderSessionManager renderiza o gerenciador de sess√µes
func (a *App) renderSessionManager() string {
	var content strings.Builder

	var title string
	if a.model.PreviousState == models.StateClusterDiscovery {
		title = titleStyle.Render("üíæ Carregar Sess√£o Salva")
	} else {
		title = titleStyle.Render("üíæ Gerenciador de Sess√µes")
	}
	content.WriteString(title + "\n\n")

	// Sess√£o atual
	if a.model.CurrentSession != nil {
		currentInfo := fmt.Sprintf("üíæ Sess√£o Atual: \"%s\"", a.model.CurrentSession.Name)
		content.WriteString(currentInfo + "\n\n")
	}

	// Mudan√ßas pendentes
	if len(a.model.HPAs) > 0 {
		content.WriteString(a.renderPendingChanges())
		content.WriteString("\n")
	}

	// Sess√µes salvas
	content.WriteString(a.renderSavedSessions())

	// Campo de nome da sess√£o
	sessionName := a.model.SessionName
	var nameField string
	var help string
	
	if a.model.EnteringSessionName {
		// Modo de entrada de texto
		if sessionName == "" {
			nameField = "Digite o nome: [                    ]"
		} else {
			nameField = fmt.Sprintf("Digite o nome: [%-20s]", sessionName)
		}
		help = "[ENTER] Salvar  [ESC] Cancelar  [BACKSPACE] Apagar"
	} else {
		// Modo normal
		if sessionName == "" {
			sessionName = "nova-sessao"
		}
		nameField = fmt.Sprintf("Nome da Sess√£o: [%-20s]", sessionName)
		help = "‚Üë‚Üì navegar  [ENTER/Ctrl+L] Carregar  [Ctrl+N] Nova  [Ctrl+W] Salvar  [Ctrl+D] Deletar  [ESC] Voltar"
	}
	
	content.WriteString("\n" + nameField + "\n\n")

	// Instru√ß√µes
	content.WriteString(helpStyle.Render(help))

	return content.String()
}

// renderPendingChanges renderiza as mudan√ßas pendentes
func (a *App) renderPendingChanges() string {
	var items []string

	for _, hpa := range a.model.HPAs {
		if hpa.Modified {
			var changes []string

			minOrig := getIntValue(hpa.OriginalValues.MinReplicas)
			minCurr := getIntValue(hpa.MinReplicas)
			if minOrig != minCurr {
				changes = append(changes, fmt.Sprintf("Min: %d‚Üí%d", minOrig, minCurr))
			}

			maxOrig := hpa.OriginalValues.MaxReplicas
			maxCurr := hpa.MaxReplicas
			if maxOrig != maxCurr {
				changes = append(changes, fmt.Sprintf("Max: %d‚Üí%d", maxOrig, maxCurr))
			}

			if len(changes) > 0 {
				changeText := strings.Join(changes, ", ")
				item := fmt.Sprintf("‚ú® %s (%s/%s)      %s",
					hpa.Name, hpa.Cluster, hpa.Namespace, changeText)
				items = append(items, normalStyle.Render("  "+item))
			}
		}
	}

	if len(items) == 0 {
		items = append(items, normalStyle.Render("  Nenhuma mudan√ßa pendente"))
	}

	boxContent := "Mudan√ßas Pendentes\n\n" + strings.Join(items, "\n")
	return boxStyle.Render(boxContent)
}

// renderSavedSessions renderiza as sess√µes salvas com navega√ß√£o
func (a *App) renderSavedSessions() string {
	var items []string

	if len(a.model.Sessions) > 0 {
		for i, session := range a.model.Sessions {
			age := "hoje"
			if !session.CreatedAt.IsZero() {
				// Calcular idade da sess√£o de forma simples
				hours := int(session.CreatedAt.Sub(session.CreatedAt).Hours())
				if hours > 24 {
					age = fmt.Sprintf("%d dias", hours/24)
				} else if hours > 1 {
					age = fmt.Sprintf("%dh atr√°s", hours)
				}
			}

			hpaCount := len(session.Changes)
			clusterCount := 1
			if session.Metadata != nil {
				clusterCount = len(session.Metadata.ClustersAffected)
			}

			// Cursor e estilo baseado na sele√ß√£o
			var cursor string
			var itemStyle lipgloss.Style
			if i == a.model.SelectedIndex {
				cursor = "‚ñ∂ "
				itemStyle = selectedStyle
			} else {
				cursor = "  "
				itemStyle = normalStyle
			}

			item := fmt.Sprintf("%süìã %s    %s", cursor, session.Name, age)
			details := fmt.Sprintf("     ‚îî‚îÄ %d HPAs | %d clusters", hpaCount, clusterCount)

			items = append(items, itemStyle.Render(item))
			items = append(items, normalStyle.Render(details))
			items = append(items, "") // Linha em branco
		}
	} else {
		items = append(items, normalStyle.Render("  Nenhuma sess√£o salva"))
	}

	boxContent := "Sess√µes Salvas\n\n" + strings.Join(items, "\n")
	return boxStyle.Render(boxContent)
}

// renderOperationProgress renderiza o progresso das opera√ß√µes
func (a *App) renderOperationProgress() string {
	var content strings.Builder

	title := titleStyle.Render("üöÄ Aplicando Mudan√ßas")
	content.WriteString(title + "\n\n")

	// Progresso geral
	total := len(a.model.Operations)
	completed := 0
	failed := 0

	for _, op := range a.model.Operations {
		switch op.Status {
		case models.OpCompleted:
			completed++
		case models.OpFailed:
			failed++
		}
	}

	progressText := fmt.Sprintf("üöÄ Progresso: %d/%d opera√ß√µes processadas", completed+failed, total)
	if failed > 0 {
		progressText += fmt.Sprintf(" (%d falhas)", failed)
	}
	content.WriteString(progressText + "\n\n")

	// Log de opera√ß√µes
	content.WriteString(a.renderOperationLog())

	// Status por HPA
	content.WriteString(a.renderOperationStatus())

	// Instru√ß√µes
	if completed+failed < total {
		help := "[ESC] Cancelar opera√ß√µes restantes"
		content.WriteString("\n" + helpStyle.Render(help))
	} else {
		help := "[ENTER] Continuar  [ESC] Voltar"
		content.WriteString("\n" + helpStyle.Render(help))
	}

	return content.String()
}

// renderOperationLog renderiza o log de opera√ß√µes
func (a *App) renderOperationLog() string {
	var items []string

	for _, op := range a.model.Operations {
		var statusIcon string
		var style lipgloss.Style = normalStyle

		switch op.Status {
		case models.OpCompleted:
			statusIcon = "‚úÖ"
			style = successStyle
		case models.OpFailed:
			statusIcon = "‚ùå"
			style = errorStyle
		case models.OpInProgress:
			statusIcon = "‚è≥"
			style = warningStyle
		case models.OpPending:
			statusIcon = "üìã"
		case models.OpCancelled:
			statusIcon = "üö´"
			style = warningStyle
		}

		message := op.Message
		if op.Error != "" {
			message = op.Error
		}

		item := fmt.Sprintf("%s %s", statusIcon, message)
		items = append(items, style.Render("  "+item))
	}

	if len(items) == 0 {
		items = append(items, normalStyle.Render("  Nenhuma opera√ß√£o"))
	}

	boxContent := "Log de Opera√ß√µes\n\n" + strings.Join(items, "\n")
	return boxStyle.Render(boxContent)
}

// renderOperationStatus renderiza o status por HPA
func (a *App) renderOperationStatus() string {
	var items []string

	// Agrupar opera√ß√µes por HPA
	hpaOps := make(map[string][]models.Operation)
	for _, op := range a.model.Operations {
		hpaOps[op.Target] = append(hpaOps[op.Target], op)
	}

	for target, ops := range hpaOps {
		// Determinar status geral do HPA
		var status string
		var style lipgloss.Style = normalStyle

		allCompleted := true
		hasFailure := false
		inProgress := false

		for _, op := range ops {
			switch op.Status {
			case models.OpFailed:
				hasFailure = true
				allCompleted = false
			case models.OpInProgress:
				inProgress = true
				allCompleted = false
			case models.OpPending:
				allCompleted = false
			}
		}

		if hasFailure {
			status = "‚ùå Failed"
			style = errorStyle
		} else if inProgress {
			status = "üîÑ In Progress..."
			style = warningStyle
		} else if allCompleted {
			status = "‚úÖ Applied + Rolled out"
			style = successStyle
		} else {
			status = "‚è≥ Pending"
		}

		// Extrair nome do HPA do target
		parts := strings.Split(target, "/")
		hpaName := target
		if len(parts) >= 3 {
			hpaName = parts[2] // cluster/namespace/hpa
		}

		item := fmt.Sprintf("%-20s %s", hpaName, status)
		items = append(items, style.Render("  "+item))
	}

	if len(items) == 0 {
		items = append(items, normalStyle.Render("  Nenhuma opera√ß√£o"))
	}

	boxContent := "Status por HPA\n\n" + strings.Join(items, "\n")
	return boxStyle.Render(boxContent)
}

// Fun√ß√µes utilit√°rias

// getIntValue retorna o valor de um ponteiro int32 ou 0 se for nil
func getIntValue(val *int32) int32 {
	if val == nil {
		return 0
	}
	return *val
}

// truncateString trunca uma string para o tamanho especificado
func truncateString(s string, maxLen int) string {
	if len(s) <= maxLen {
		return s
	}
	return s[:maxLen-3] + "..."
}

// formatDuration formata uma dura√ß√£o de forma leg√≠vel
func formatDuration(hours int) string {
	if hours < 1 {
		return "agora"
	}
	if hours < 24 {
		return fmt.Sprintf("%dh atr√°s", hours)
	}
	days := hours / 24
	if days == 1 {
		return "1 dia atr√°s"
	}
	if days < 7 {
		return fmt.Sprintf("%d dias atr√°s", days)
	}
	weeks := days / 7
	if weeks == 1 {
		return "1 semana atr√°s"
	}
	return fmt.Sprintf("%d semanas atr√°s", weeks)
}
